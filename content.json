[{"title":"陈氏菜谱其一","date":"2017-09-07T08:29:49.000Z","path":"2017/09/07/cooking-chenc-20170910/","text":"离职在家休息这段时间学了学做饭，其实做饭也没什么特别难的，想吃什么了就去查，然后照着菜谱做就好了。室友和同学都觉得还ok，能吃，于是就想着发出来记录一下。这里列了四菜一汤，招待亲友吃一顿还是足够的。以后可能还会有陈氏菜谱其二，看时间和心情。嗯。 香蒜虾焖饭 做法: 处理虾，去虾头，挑虾线 开火，加食用油，煸炒虾头，挤出虾油，加适量料酒，加水、盐，大火熬制高汤，大约10分钟后筛出虾头，高汤出锅备用 取虾仁，切段，加入料酒、盐、白胡椒腌制备用 大米淘洗后沥干备用 开火，加食用油，葱花炒香，加入胡萝卜丁、洋葱丁、蒜末翻炒片刻，加入沥干的大米翻炒出锅，倒入砂锅(电饭锅也行，砂锅容易糊锅) 砂锅加入生抽、豌豆粒，小火焖15分钟 开火，加食用油，蒜末炒香，加入虾段煸炒，盛出备用 米饭熟后加入虾段即可 红烧肉 做法: 五花肉切块，冷水下锅焯水，盛出洗净备用 冷锅冷油，冰糖30g小火炒出焦糖色，放入开水 肉块下锅，1勺老抽、2勺生抽、4勺黄酒、生姜5片、山楂若干，加开水没过五花肉(水要加够)，加盖小火1小时，大火收汁出锅 砂锅牛肉 做法: 牛肉(腱子肉)切块，清水浸泡1小时，浸泡出血水 开火，食用油，放入葱姜段大料煸炒出香味 加入牛肉翻炒1-2分钟，加两勺料酒两勺醋 原汤牛肉倒入砂锅，适量开水、山楂，水一次性加够，炖1小时，开锅后转小火 肉口感OK后可加入土豆胡萝卜块，1勺老抽、2勺生抽、1勺白糖、番茄酱、黑胡椒，再炖30分钟 大火收汁，加入彩椒翻炒出锅 糖醋虾 做法: 虾去虾线，备用 开火，食用油，加入大量葱丝、姜丝煸香，加入处理后的虾煸炒，煸炒变红后加入番茄酱、白糖，大火翻炒炒匀后出锅即可 汆丸子 做法: 肉馅，加葱花姜末，一个鸡蛋搅拌 少量多次加入清水，每次加水都沿同一方向搅拌直至水分完全吸收 加入鸡精、生抽、盐、胡椒粉，搅拌均匀入味 烧水，开锅后用虎口挤丸子下锅 撇净浮沫，加盐、鸡精、香油调味，撒上香菜出锅即可","tags":[{"name":"好吃的","slug":"好吃的","permalink":"http://www.chenc.cc/tags/好吃的/"},{"name":"香蒜虾焖饭","slug":"香蒜虾焖饭","permalink":"http://www.chenc.cc/tags/香蒜虾焖饭/"},{"name":"汆丸子","slug":"汆丸子","permalink":"http://www.chenc.cc/tags/汆丸子/"},{"name":"红烧肉","slug":"红烧肉","permalink":"http://www.chenc.cc/tags/红烧肉/"},{"name":"糖醋虾","slug":"糖醋虾","permalink":"http://www.chenc.cc/tags/糖醋虾/"},{"name":"砂锅牛肉","slug":"砂锅牛肉","permalink":"http://www.chenc.cc/tags/砂锅牛肉/"}]},{"title":"《高性能MySQL》学习笔记之索引篇","date":"2017-08-15T06:09:14.000Z","path":"2017/08/15/mysql-table-design-index/","text":"索引类型(在存储引擎层实现)B-TREE索引所有的值都是按照顺序存储的，并且每个叶子节点到根节点的距离相同不再需要全表扫描，从索引根节点开始搜索到叶子节点，叶子节点指向被索引的数据排序中也可以用到 可使用B-TREE索引的查询类型 全值匹配 匹配最左前缀 匹配列前缀 匹配范围值 精确匹配某一列并范围匹配另一列 只访问索引的查询 限制 如果不是按照最左列开始查找则无法使用索引 不能跳过索引中的列 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引 哈希索引基于哈希表实现的索引，只有精确匹配所有列才能有效，查找极快 限制 哈希索引只包含哈希值和行指针，不存储字段值，需要回表读取行信息 哈希索引不是按照索引值顺序存储的，不能用于排序 不支持部分列查找 只能等值查找 可能有哈希冲突 冲突多时维护成本高 空间数据索引 R-TREEMYISAM中支持，可用作地理数据存储，无需前缀查询，必须使用MySQL的GIS相关函数来维护数据MySQL对此支持不完善 全文索引和其他没实际用处，可通过Lucene等实现 索引的优点 可以让服务器快速定位到表的指定位置 大大减少了服务器需要扫描的数据量 可以帮助服务器避免排序和临时表 可以将随机I/O 编程顺序I/O 高性能索引策略独立的列索引列不能是表达式的一部分，也不能是参数 1select aid from a where aid + 1 = 5 # 错误示例 前缀索引和索引的选择性前缀索引使用开始部分的字符来节约空间选多长前缀合适，可通过计算获得 先计算整表的选择性 1select count(distinct city) / count(*) from demo 再计算接近上述结果的长度 1select count(distinct left(city,3)) / count(*) from demo 创建前缀索引 1alter table demo add key (city(3)) 选择合适的索引及列顺序在一个多列的b-tree索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列等等。所以，索引可以按照升序或降序进行扫描，以满足精确符合列顺序的order by，group by，distinct等子句的查询需求 法则:将选择性高的列放到索引最前列 聚集索引当表有聚集索引时，它的数据实际存放在叶子节点中一个表只能有一个聚集索引不是所有的存储引擎都支持聚集索引 聚集索引的创建 InnoDB 通过主键聚集数据 未定义主键 选择一个唯一的非空索引代替 没有这样的索引 InnoDB 将隐式定义一个主键来代替 优点 可以把相关数据保存在一起 数据访问更快 使用覆盖索引扫描的查询可以直接使用叶节点中的键值 缺点 数据在内存中时，访问顺序不主要，优势消失 插入数据严重依赖插入顺序 更新聚集索引列代价高 移动位置 移动行时页分裂问题 全表扫描变慢 二级索引更大 二级索引要两次查找而不是一次 覆盖索引 一个索引包含所有需要查询的字段值（字段，条件，排序等），查询只需要扫描索引而无需回表 好处 减少数据访问量 顺序存储 io 少 对innodb表特别有用 MYSQL只能用B-TREE索引来做覆盖索引MySQL不能在索引中执行like操作 使用索引扫描来做排序MySQL获得有序结果的方式：排序操作或按照索引顺序扫描如果explain中 type：index 说明按照索引扫描排序 只有当索引列顺序和orderby子句顺序完全一致且所有列排序方向都一样的时候，MySQL才会用索引来排序 如果查询关联多张表，只有当orderby引用字段全部为第一张表时，才能用索引排序 最左前缀或前导列为常量 压缩索引MyISAM使用前缀压缩来减少索引大小，从而让更多的索引放入内存中压缩方法:先保存索引块中的第一个值，然后将其他值和第一个值进行比较，得到相同的字节数和生育的不同后缀部分如 perform performance =&gt; perform 7,ance不适用于io密集型应用","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.chenc.cc/tags/MySQL/"}]},{"title":"《高性能MySQL》学习笔记之数据类型篇","date":"2017-08-14T06:09:14.000Z","path":"2017/08/14/mysql-table-design-datatype/","text":"数据类型 整数类型 TINYINT,SMALLINT,MEDIUMINT,INT,BIGINT分别使用8，16，24，32，64位存储空间，存储的值范围为-2^(N-1)~2^(N-1)-1根据要存储的数据大小选择合适的整数类型UNSIGNED可选属性，表示不允许负值，只存非负整数相应地存储正数上限也大了一倍 实数类型 FLOAT,DOUBLE类型支持使用标准型的浮点运算进行近似计算DECIMAL用于存储精确的小数，数据量较大时建议使用BIGINT代替 DECIMAL，将需要存储的货币单位根据小数的位数乘以相应的倍数进行存储 VARCHAR,CHAR VARCHAR用于存储可变长字符串，它比定长字符串更节省空间，仅使用必要的空间。以下情况使用varchar是合适的：字符串列的最大长度比平均长度大很多；列的更新很少，所以碎片不是问题；使用像utf-8这样的复杂字符集，每个字符都使用不同的字节数进行存储。char类型的长度是定长的，适合存储很短的字符串，或者所有值都接近同一长度，经常变更的列等 BLOB,TEXT类型 BLOB,TEXT都是为存储很大的数据而设计的的字符串类型，分别采用二进制和文本方式存储。 ENUM枚举类型 MySQL在内部会将每个值在表中的位置保存为整数，且排序是按照对应的数字进行排序并不是按字符串不建议使用的类型 时间类型 DATATIME和TIMESTAMPDATATIM能保存大范围的值，从1001年到9999年精确到秒，与时区无关，使用8字节存储空间TIMESTAMP保存了从1970-01-01 00:00:00（格林尼治时间）以来的秒数，只用4字节存储空间，只能表示1970～2038年，与时区有关，会自动调整，除特殊行为之外尽量使用，因为其效率更高不要将unix时间戳作为整数存储到数据库，不好处理 优化数据类型 尽量使用可以正确存储数据的最小数据类型 占用更少的cpu、内存、磁盘等 尽量使用简单的数据类型 整型比字符串的操作代价更低应该使用mysql自建的数据类型来存储日期和时间应该用整型存储IP地址（32位无符号整数 inet_aton() inet_ntoa()） 尽量避免null 可为null的列使得索引、索引统计和值都更复杂，会占用更多的存储空间且需要mysql特殊处理","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.chenc.cc/tags/MySQL/"}]},{"title":"MySQL 插入时如果存在则更新","date":"2017-07-17T11:29:49.000Z","path":"2017/07/17/mysql-insert-or-update/","text":"SQL123INSERT INTO testable (a,b,c) VALUES (2,3,5),(7,6,7) ON DUPLICATE KEY UPDATE a=VALUES(a),b=VALUES(b),c=VALUES(c) 注意 要先添加唯一索引，MySQL根据唯一索引来判断是否重复 优点 效率高，判断当存在重复值时直接在当前行上更新，无需更新索引 问题 发现语句执行后即便没有插入数据表的自增主键还是进行了更新。 其他方法 replace 语法 SQL 1replace into testable (a, b, c) values(1, 2, 3),(11, 12, 13) MySQL 提供的语法 效率相比ON DUPLICATE KEY UPDATE 效率较低(因为他的操作方式是判断是否存在，存在则删除旧数据再插入新数据，删除和插入数据后都需更新索引，数据量较大的时候比较消耗性能)","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.chenc.cc/tags/MySQL/"},{"name":"程序员","slug":"程序员","permalink":"http://www.chenc.cc/tags/程序员/"}]},{"title":"Memcached::cas 乐观锁","date":"2017-06-10T11:03:14.000Z","path":"2017/06/10/php-memcached-cas/","text":"说明1public bool Memcached::cas ( float $cas_token , string $key , mixed $value [, int $expiration ] ) Memcached::cas()执行一个“检查并设置”的操作，因此，它仅在当前客户端最后一次取值后，该key 对应的值没有被其他客户端修改的情况下， 才能够将值写入。检查是通过cas_token参数进行的，这个参数是Memcach指定给已经存在的元素的一个唯一的64位值， 怎样获取这个值请查看Memcached::get*()系列方法的文档。注意：这个值作为double类型是因为PHP的整型空间限制。当该key被其他客户端更新后，cas_token将被更新，写入时将判断读取时获取的cas_token与当前cas_token是否一致，不一致则拒绝更新。 译注：这是Memcached扩展比Memcache扩展一个非常重要的优势， 在这样一个系统级（Memcache自身提供）的冲突检测机制（乐观锁）下， 我们才能保证高并发下的数据安全。 参数 cas_token与已存在元素关联的唯一的值，由Memcache生成。 key用于存储值的键名。 value存储的值。 expiration到期时间，默认为 0。 更多信息请参见到期时间。 返回值成功时返回 TRUE， 或者在失败时返回 FALSE。 如果在元素尝试存储时发现在本客户端最后一次获取后被其他客户端修改，Memcached::getResultCode() 将返回 Memcached::RES_DATA_EXISTS。 范例12345678910111213141516171819&lt;?php$m = new Memcached();$m-&gt;addServer('localhost', 11211);do &#123; /* 获取ip列表以及它的标记 */ $ips = $m-&gt;get('ip_block', null, $cas); /* 如果列表不存在， 创建并进行一个原子添加（如果其他客户端已经添加， 这里就返回false）*/ if ($m-&gt;getResultCode() == Memcached::RES_NOTFOUND) &#123; $ips = array($_SERVER['REMOTE_ADDR']); $m-&gt;add('ip_block', $ips); /* 其他情况下，添加ip到列表中， 并以cas方式去存储， 这样当其他客户端修改过， 则返回false */ &#125; else &#123; $ips[] = $_SERVER['REMOTE_ADDR']; $m-&gt;cas($cas, 'ip_block', $ips); &#125; &#125; while ($m-&gt;getResultCode() != Memcached::RES_SUCCESS);?&gt;","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.chenc.cc/tags/PHP/"},{"name":"Memcached","slug":"Memcached","permalink":"http://www.chenc.cc/tags/Memcached/"}]},{"title":"北邮附近的好吃的！","date":"2017-06-07T08:29:49.000Z","path":"2017/06/07/food-around-bupt/","text":"有大神梳理了北邮附近的各种好吃的，从食堂到外卖，从小店到餐厅。。。这里偷懒直接截个图收藏了~","tags":[{"name":"好吃的","slug":"好吃的","permalink":"http://www.chenc.cc/tags/好吃的/"}]},{"title":"【多图】家有美女初长成","date":"2017-06-07T08:11:51.000Z","path":"2017/06/07/golden-2017-06-07/","text":"【多图】家有美女初长成","tags":[{"name":"金大毛","slug":"金大毛","permalink":"http://www.chenc.cc/tags/金大毛/"},{"name":"金毛嘟","slug":"金毛嘟","permalink":"http://www.chenc.cc/tags/金毛嘟/"}]},{"title":"TiUP技术分享--Git的基本命令和工作流简介","date":"2017-05-12T12:32:12.000Z","path":"2017/05/12/tiup-salon-git/","text":"今天在团队技术沙龙主讲了Git的基本命令和工作流简介的相关内容，现将讲稿发到这里，供大家参考","tags":[{"name":"Git","slug":"Git","permalink":"http://www.chenc.cc/tags/Git/"},{"name":"技术沙龙","slug":"技术沙龙","permalink":"http://www.chenc.cc/tags/技术沙龙/"}]},{"title":"正则表达式学习笔记","date":"2017-05-10T11:01:12.000Z","path":"2017/05/10/regexp-notes/","text":"元字符 代码 说明 . 匹配除换行符以外的任意字符 \\w 匹配字母或数字或下划线或汉字 \\s 匹配任意的空白符 \\d 匹配数字 \\b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 字符转义\\转义 重复 代码/语法 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 字符类方括号里列出，像[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!) 分枝条件| 分隔整个表达式，表示或的关系 分组用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作 反义 代码/语法 说明 \\W 匹配任意不是字母，数字，下划线，汉字的字符 \\S 匹配任意不是空白符的字符 \\D 匹配任意非数字的字符 \\B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou] 匹配除了aeiou这几个字母以外的任意字符 后向引用 分类 代码/语法 说明 捕获 (exp) 匹配exp,并捕获文本到自动命名的组里 捕获 (?&lt;name&gt;exp) 匹配exp,并捕获文本到名称为name的组里，也可以写成(?&#39;name&#39;exp) 捕获 (?:exp) 匹配exp,不捕获匹配的文本，也不给此分组分配组号 零宽断言 (?=exp) 匹配exp前面的位置 零宽断言 (?&lt;=exp) 匹配exp后面的位置 零宽断言 (?!exp) 匹配后面跟的不是exp的位置 零宽断言 (?&lt;!exp) 匹配前面不是exp的位置 注释 (?#comment) 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读 贪婪与懒惰正则表达式通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号? 代码/语法 说明 *? 重复任意次，但尽可能少重复 +? 重复1次或更多次，但尽可能少重复 ?? 重复0次或1次，但尽可能少重复 {n,m}? 重复n到m次，但尽可能少重复 {n,}? 重复n次以上，但尽可能少重复 处理选项 名称 说明 IgnoreCase(忽略大小写) 匹配时不区分大小写。 Multiline(多行模式) 更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\\n之前的位置以及字符串结束前的位置.) Singleline(单行模式) 更改.的含义，使它与每一个字符匹配（包括换行符\\n）。 IgnorePatternWhitespace(忽略空白) 忽略表达式中的非转义空白并启用由#标记的注释。 ExplicitCapture(显式捕获) 仅捕获已被显式命名的组。 其他语法 代码/语法 说明 \\a 报警字符(打印它的效果是电脑嘀一声) \\b 通常是单词分界位置，但如果在字符类里使用代表退格 \\t 制表符，Tab \\r 回车 \\v 竖向制表符 \\f 换页符 \\n 换行符 \\e Escape \\0nn ASCII代码中八进制代码为nn的字符 \\xnn ASCII代码中十六进制代码为nn的字符 \\unnnn Unicode代码中十六进制代码为nnnn的字符 \\cN ASCII控制字符。比如\\cC代表Ctrl+C \\A 字符串开头(类似^，但不受处理多行选项的影响) \\Z 字符串结尾或行尾(不受处理多行选项的影响) \\z 字符串结尾(类似$，但不受处理多行选项的影响) `\\G 当前搜索的开头` \\p{name} Unicode中命名为name的字符类，例如\\p{IsGreek} `(?&gt;exp) 贪婪子表达式` (?&lt;x&gt;-&lt;y&gt;exp) 平衡组 (?im-nsx:exp) 在子表达式exp中改变处理选项 (?im-nsx) 为表达式后面的部分改变处理选项 (?(exp)yes no) 把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no (?(exp)yes) 同上，只是使用空表达式作为no (?(name)yes no) 如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no (?(name)yes) 同上，只是使用空表达式作为no","tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://www.chenc.cc/tags/正则表达式/"}]},{"title":"TiUP技术分享 -- 微信公众号开发","date":"2016-04-15T13:24:47.000Z","path":"2016/04/15/tiup-salon-wechat-dev/","text":"今天在团队技术沙龙主讲了微信公众号的相关内容，现将讲稿发到这里","tags":[{"name":"微信服务号","slug":"微信服务号","permalink":"http://www.chenc.cc/tags/微信服务号/"},{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://www.chenc.cc/tags/OAuth2-0/"},{"name":"技术沙龙","slug":"技术沙龙","permalink":"http://www.chenc.cc/tags/技术沙龙/"}]},{"title":"PHP哈希表碰撞攻击原理","date":"2016-03-16T00:12:43.000Z","path":"2016/03/16/php-gc/","text":"转载自伯乐在线 哈希表碰撞攻击的基本原理哈希表是一种查找效率极高的数据结构，很多语言都在内部实现了哈希表。PHP中的哈希表是一种极为重要的数据结构，不但用于表示Array数据类型，还在Zend虚拟机内部用于存储上下文环境信息（执行上下文的变量及函数均使用哈希表结构存储）。理想情况下哈希表插入和查找操作的时间复杂度均为O(1)，任何一个数据项可以在一个与哈希表长度无关的时间内计算出一个哈希值（key），然后在常量时间内定位到一个桶（术语bucket，表示哈希表中的一个位置）。当然这是理想情况下，因为任何哈希表的长度都是有限的，所以一定存在不同的数据项具有相同哈希值的情况，此时不同数据项被定为到同一个桶，称为碰撞（collision）。哈希表的实现需要解决碰撞问题，碰撞解决大体有两种思路，第一种是根据某种原则将被碰撞数据定为到其它桶，例如线性探测——如果数据在插入时发生了碰撞，则顺序查找这个桶后面的桶，将其放入第一个没有被使用的桶；第二种策略是每个桶不是一个只能容纳单个数据项的位置，而是一个可容纳多个数据的数据结构（例如链表或红黑树），所有碰撞的数据以某种数据结构的形式组织起来。 不论使用了哪种碰撞解决策略，都导致插入和查找操作的时间复杂度不再是O(1)。以查找为例，不能通过key定位到桶就结束，必须还要比较原始key（即未做哈希之前的key）是否相等，如果不相等，则要使用与插入相同的算法继续查找，直到找到匹配的值或确认数据不在哈希表中。 PHP是使用单链表存储碰撞的数据，因此实际上PHP哈希表的平均查找复杂度为O(L)，其中L为桶链表的平均长度；而最坏复杂度为O(N)，此时所有数据全部碰撞，哈希表退化成单链表。下图PHP中正常哈希表和退化哈希表的示意图。哈希表碰撞攻击就是通过精心构造数据，使得所有数据全部碰撞，人为将哈希表变成一个退化的单链表，此时哈希表各种操作的时间均提升了一个数量级，因此会消耗大量CPU资源，导致系统无法快速响应请求，从而达到拒绝服务攻击（DoS）的目的。 可以看到，进行哈希碰撞攻击的前提是哈希算法特别容易找出碰撞，如果是MD5或者SHA1那基本就没戏了，幸运的是（也可以说不幸的是）大多数编程语言使用的哈希算法都十分简单（这是为了效率考虑），因此可以不费吹灰之力之力构造出攻击数据。下一节将通过分析Zend相关内核代码，找出攻击哈希表碰撞攻击PHP的方法。 Zend哈希表的内部实现数据结构PHP中使用一个叫Backet的结构体表示桶，同一哈希值的所有桶被组织为一个单链表。哈希表使用HashTable结构体表示。相关源码在zend/Zend_hash.h下：1234567891011121314151617181920212223242526272829typedef struct bucket &#123; ulong h; /* Used for numeric indexing */ uint nKeyLength; void *pData; void *pDataPtr; struct bucket *pListNext; struct bucket *pListLast; struct bucket *pNext; struct bucket *pLast; char arKey[1]; /* Must be last element */&#125; Bucket; typedef struct _hashtable &#123; uint nTableSize; uint nTableMask; uint nNumOfElements; ulong nNextFreeElement; Bucket *pInternalPointer; /* Used for element traversal */ Bucket *pListHead; Bucket *pListTail; Bucket **arBuckets; dtor_func_t pDestructor; zend_bool persistent; unsigned char nApplyCount; zend_bool bApplyProtection;#if ZEND_DEBUG int inconsistent;#endif&#125; HashTable; 字段名很清楚的表明其用途，因此不做过多解释。重点明确下面几个字段：Bucket中的“h”用于存储原始key；HashTable中的nTableMask是一个掩码，一般被设为nTableSize – 1，与哈希算法有密切关系，后面讨论哈希算法时会详述；arBuckets指向一个指针数组，其中每个元素是一个指向Bucket链表的头指针。 哈希算法PHP哈希表最小容量是8（2^3），最大容量是0×80000000（2^31），并向2的整数次幂圆整（即长度会自动扩展为2的整数次幂，如13个元素的哈希表长度为16；100个元素的哈希表长度为128）。nTableMask被初始化为哈希表长度（圆整后）减1。具体代码在zend/Zend_hash.c的_zend_hash_init函数中，这里截取与本文相关的部分并加上少量注释。123456789101112131415161718192021222324ZEND_API int _zend_hash_init(HashTable *ht, uint nSize, hash_func_t pHashFunction, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)&#123; uint i = 3; Bucket **tmp; SET_INCONSISTENT(HT_OK); //长度向2的整数次幂圆整 if (nSize &amp;gt;= 0x80000000) &#123; /* prevent overflow */ ht-&amp;gt;nTableSize = 0x80000000; &#125; else &#123; while ((1U &amp;lt;&amp;lt; i) &amp;lt; nSize) &#123; i++; &#125; ht-&amp;gt;nTableSize = 1 &amp;lt;&amp;lt; i; &#125; ht-&amp;gt;nTableMask = ht-&amp;gt;nTableSize - 1; /*此处省略若干代码…*/ return SUCCESS;&#125; 值得一提的是PHP向2的整数次幂取圆整方法非常巧妙，可以背下来在需要的时候使用。 Zend HashTable的哈希算法异常简单：即简单将数据的原始key与HashTable的nTableMask进行按位与即可。如果原始key为字符串，则首先使用Times33算法将字符串转为整形再与nTableMask按位与。下面是Zend源码中查找哈希表的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243ZEND_API int zend_hash_index_find(const HashTable *ht, ulong h, void **pData)&#123; uint nIndex; Bucket *p; IS_CONSISTENT(ht); nIndex = h &amp; ht-&gt;nTableMask; p = ht-&gt;arBuckets[nIndex]; while (p != NULL) &#123; if ((p-&gt;h == h) &amp;&amp; (p-&gt;nKeyLength == 0)) &#123; *pData = p-&gt;pData; return SUCCESS; &#125; p = p-&gt;pNext; &#125; return FAILURE;&#125;ZEND_API int zend_hash_find(const HashTable *ht, const char *arKey, uint nKeyLength, void **pData)&#123; ulong h; uint nIndex; Bucket *p; IS_CONSISTENT(ht); h = zend_inline_hash_func(arKey, nKeyLength); nIndex = h &amp; ht-&gt;nTableMask; p = ht-&gt;arBuckets[nIndex]; while (p != NULL) &#123; if ((p-&gt;h == h) &amp;&amp; (p-&gt;nKeyLength == nKeyLength)) &#123; if (!memcmp(p-&gt;arKey, arKey, nKeyLength)) &#123; *pData = p-&gt;pData; return SUCCESS; &#125; &#125; p = p-&gt;pNext; &#125; return FAILURE;&#125; 其中zend_hash_index_find用于查找整数key的情况，zend_hash_find用于查找字符串key。逻辑基本一致，只是字符串key会通过zend_inline_hash_func转为整数key，zend_inline_hash_func封装了times33算法，具体代码就不贴出了。 攻击基本攻击知道了PHP内部哈希表的算法，就可以利用其原理构造用于攻击的数据。一种最简单的方法是利用掩码规律制造碰撞。上文提到Zend HashTable的长度nTableSize会被圆整为2的整数次幂，假设我们构造一个2^16的哈希表，则nTableSize的二进制表示为：1 0000 0000 0000 0000，而nTableMask = nTableSize – 1为：0 1111 1111 1111 1111。接下来，可以以0为初始值，以2^16为步长，制造足够多的数据，可以得到如下推测： 0000 0000 0000 0000 0000 &amp; 0 1111 1111 1111 1111 = 0 0001 0000 0000 0000 0000 &amp; 0 1111 1111 1111 1111 = 0 0010 0000 0000 0000 0000 &amp; 0 1111 1111 1111 1111 = 0 0011 0000 0000 0000 0000 &amp; 0 1111 1111 1111 1111 = 0 0100 0000 0000 0000 0000 &amp; 0 1111 1111 1111 1111 = 0 …… 概况来说只要保证后16位均为0，则与掩码位于后得到的哈希值全部碰撞在位置0。 下面是利用这个原理写的一段攻击代码：12345678910111213&lt;?php$size = pow(2, 16); $startTime = microtime(true); $array = array();for ($key = 0, $maxKey = ($size - 1) * $size; $key &lt;= $maxKey; $key += $size) &#123; $array[$key] = 0;&#125; $endTime = microtime(true); echo $endTime - $startTime, ' seconds', \"\\n\"; 这段代码在我的VPS上（单CPU，512M内存）上用了近88秒才完成，并且在此期间CPU资源几乎被用尽：而普通的同样大小的哈希表插入仅用时0.036秒：1234567891011121314&lt;?php $size = pow(2, 16); $startTime = microtime(true); $array = array();for ($key = 0, $maxKey = ($size - 1) * $size; $key &lt;= $size; $key += 1) &#123; $array[$key] = 0;&#125; $endTime = microtime(true); echo $endTime - $startTime, ' seconds', \"\\n\"; 可以证明第二段代码插入N个元素的时间在O(N)水平，而第一段攻击代码则需O(N^2)的时间去插入N个元素。 POST攻击当然，一般情况下很难遇到攻击者可以直接修改PHP代码的情况，但是攻击者仍可以通过一些方法间接构造哈希表来进行攻击。例如PHP会将接收到的HTTP POST请求中的数据构造为$_POST，而这是一个Array，内部就是通过Zend HashTable表示，因此攻击者只要构造一个含有大量碰撞key的post请求，就可以达到攻击的目的。具体做法不再演示。 防护POST攻击的防护针对POST方式的哈希碰撞攻击，目前PHP的防护措施是控制POST数据的数量。在&gt;=PHP5.3.9的版本中增加了一个配置项max_input_vars，用于标识一次http请求最大接收的参数个数，默认为1000。因此PHP5.3.x的用户可以通过升级至5.3.9来避免哈希碰撞攻击。5.2.x的用户可以使用这个patch：http://www.laruence.com/2011/12/30/2440.html。 另外的防护方法是在Web服务器层面进行处理，例如限制http请求body的大小和参数的数量等，这个是现在用的最多的临时处理方案。具体做法与不同Web服务器相关，不再详述。 其它防护上面的防护方法只是限制POST数据的数量，而不能彻底解决这个问题。例如，如果某个POST字段是一个json数据类型，会被PHPjson_decode，那么只要构造一个超大的json攻击数据照样可以达到攻击目的。理论上，只要PHP代码中某处构造Array的数据依赖于外部输入，则都可能造成这个问题，因此彻底的解决方案要从Zend底层HashTable的实现动手。一般来说有两种方式，一是限制每个桶链表的最长长度；二是使用其它数据结构如红黑树取代链表组织碰撞哈希（并不解决哈希碰撞，只是减轻攻击影响，将N个数据的操作时间从O(N^2)降至O(NlogN)，代价是普通情况下接近O(1)的操作均变为O(logN)）。 目前使用最多的仍然是POST数据攻击，因此建议生产环境的PHP均进行升级或打补丁。至于从数据结构层面修复这个问题，目前还没有任何方面的消息。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.chenc.cc/tags/PHP/"},{"name":"哈希碰撞","slug":"哈希碰撞","permalink":"http://www.chenc.cc/tags/哈希碰撞/"}]}]