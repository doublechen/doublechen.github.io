[{"title":"mysql数据库设计优化之数据类型篇","date":"2017-08-14T06:09:14.000Z","path":"2017/08/14/mysql-table-design-datatype/","text":"数据类型 整数类型 TINYINT,SMALLINT,MEDIUMINT,INT,BIGINT分别使用8，16，24，32，64位存储空间，存储的值范围为-2^(N-1)~2^(N-1)-1根据要存储的数据大小选择合适的整数类型UNSIGNED可选属性，表示不允许负值，只存非负整数相应地存储正数上限也大了一倍 实数类型 FLOAT,DOUBLE类型支持使用标准型的浮点运算进行近似计算DECIMAL用于存储精确的小数，数据量较大时建议使用BIGINT代替 DECIMAL，将需要存储的货币单位根据小数的位数乘以相应的倍数进行存储 VARCHAR,CHAR VARCHAR用于存储可变长字符串，它比定长字符串更节省空间，仅使用必要的空间。以下情况使用varchar是合适的：字符串列的最大长度比平均长度大很多；列的更新很少，所以碎片不是问题；使用像utf-8这样的复杂字符集，每个字符都使用不同的字节数进行存储。char类型的长度是定长的，适合存储很短的字符串，或者所有值都接近同一长度，经常变更的列等 BLOB,TEXT类型 BLOB,TEXT都是为存储很大的数据而设计的的字符串类型，分别采用二进制和文本方式存储。 ENUM枚举类型 MySQL在内部会将每个值在表中的位置保存为整数，且排序是按照对应的数字进行排序并不是按字符串不建议使用的类型 时间类型 DATATIME和TIMESTAMPDATATIM能保存大范围的值，从1001年到9999年精确到秒，与时区无关，使用8字节存储空间TIMESTAMP保存了从1970-01-01 00:00:00（格林尼治时间）以来的秒数，只用4字节存储空间，只能表示1970～2038年，与时区有关，会自动调整，除特殊行为之外尽量使用，因为其效率更高不要讲unix时间戳作为整数存储到数据库，不好处理 优化数据类型 尽量使用可以正确存储数据的最小数据类型 占用更少的cpu、内存、磁盘等 尽量使用简单的数据类型 整型比字符串的操作代价更低应该使用mysql自建的数据类型来存储日期和时间应该用整型存储IP地址（32位无符号整数 inet_aton() inet_ntoa()） 尽量避免null 可为null的列使得索引、索引统计和值都更复杂，会占用更多的存储空间且需要mysql特殊处理","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.chenc.cc/tags/MySQL/"}]},{"title":"MySQL 插入时如果存在则更新","date":"2017-07-17T11:29:49.000Z","path":"2017/07/17/mysql-insert-or-update/","text":"SQL123INSERT INTO testable (a,b,c) VALUES (2,3,5),(7,6,7) ON DUPLICATE KEY UPDATE a=VALUES(a),b=VALUES(b),c=VALUES(c) 注意 要先添加唯一索引，MySQL根据唯一索引来判断是否重复 优点 效率高，判断当存在重复值时直接在当前行上更新，无需更新索引 问题 发现语句执行后即便没有插入数据表的自增主键还是进行了更新。 其他方法 replace 语法 SQL 1replace into testable (a, b, c) values(1, 2, 3),(11, 12, 13) MySQL 提供的语法 效率相比ON DUPLICATE KEY UPDATE 效率较低(因为他的操作方式是判断是否存在，存在则删除旧数据再插入新数据，删除和插入数据后都需更新索引，数据量较大的时候比较消耗性能)","tags":[{"name":"程序员","slug":"程序员","permalink":"http://www.chenc.cc/tags/程序员/"},{"name":"MySQL","slug":"MySQL","permalink":"http://www.chenc.cc/tags/MySQL/"}]},{"title":"北邮附近的好吃的！","date":"2017-06-07T08:29:49.000Z","path":"2017/06/07/food-around-bupt/","text":"有大神梳理了北邮附近的各种好吃的，从食堂到外卖，从小店到餐厅。。。这里偷懒直接截个图收藏了~","tags":[{"name":"好吃的","slug":"好吃的","permalink":"http://www.chenc.cc/tags/好吃的/"}]},{"title":"洗白白之后美美哒","date":"2017-06-07T08:11:51.000Z","path":"2017/06/07/golden-2017-06-07/","text":"","tags":[{"name":"金大毛","slug":"金大毛","permalink":"http://www.chenc.cc/tags/金大毛/"},{"name":"金毛嘟","slug":"金毛嘟","permalink":"http://www.chenc.cc/tags/金毛嘟/"}]},{"title":"PHP哈希表碰撞攻击原理","date":"2016-03-16T00:12:43.000Z","path":"2016/03/16/php-gc/","text":"转载自伯乐在线 哈希表碰撞攻击的基本原理哈希表是一种查找效率极高的数据结构，很多语言都在内部实现了哈希表。PHP中的哈希表是一种极为重要的数据结构，不但用于表示Array数据类型，还在Zend虚拟机内部用于存储上下文环境信息（执行上下文的变量及函数均使用哈希表结构存储）。理想情况下哈希表插入和查找操作的时间复杂度均为O(1)，任何一个数据项可以在一个与哈希表长度无关的时间内计算出一个哈希值（key），然后在常量时间内定位到一个桶（术语bucket，表示哈希表中的一个位置）。当然这是理想情况下，因为任何哈希表的长度都是有限的，所以一定存在不同的数据项具有相同哈希值的情况，此时不同数据项被定为到同一个桶，称为碰撞（collision）。哈希表的实现需要解决碰撞问题，碰撞解决大体有两种思路，第一种是根据某种原则将被碰撞数据定为到其它桶，例如线性探测——如果数据在插入时发生了碰撞，则顺序查找这个桶后面的桶，将其放入第一个没有被使用的桶；第二种策略是每个桶不是一个只能容纳单个数据项的位置，而是一个可容纳多个数据的数据结构（例如链表或红黑树），所有碰撞的数据以某种数据结构的形式组织起来。 不论使用了哪种碰撞解决策略，都导致插入和查找操作的时间复杂度不再是O(1)。以查找为例，不能通过key定位到桶就结束，必须还要比较原始key（即未做哈希之前的key）是否相等，如果不相等，则要使用与插入相同的算法继续查找，直到找到匹配的值或确认数据不在哈希表中。 PHP是使用单链表存储碰撞的数据，因此实际上PHP哈希表的平均查找复杂度为O(L)，其中L为桶链表的平均长度；而最坏复杂度为O(N)，此时所有数据全部碰撞，哈希表退化成单链表。下图PHP中正常哈希表和退化哈希表的示意图。哈希表碰撞攻击就是通过精心构造数据，使得所有数据全部碰撞，人为将哈希表变成一个退化的单链表，此时哈希表各种操作的时间均提升了一个数量级，因此会消耗大量CPU资源，导致系统无法快速响应请求，从而达到拒绝服务攻击（DoS）的目的。 可以看到，进行哈希碰撞攻击的前提是哈希算法特别容易找出碰撞，如果是MD5或者SHA1那基本就没戏了，幸运的是（也可以说不幸的是）大多数编程语言使用的哈希算法都十分简单（这是为了效率考虑），因此可以不费吹灰之力之力构造出攻击数据。下一节将通过分析Zend相关内核代码，找出攻击哈希表碰撞攻击PHP的方法。 Zend哈希表的内部实现数据结构PHP中使用一个叫Backet的结构体表示桶，同一哈希值的所有桶被组织为一个单链表。哈希表使用HashTable结构体表示。相关源码在zend/Zend_hash.h下：1234567891011121314151617181920212223242526272829typedef struct bucket &#123; ulong h; /* Used for numeric indexing */ uint nKeyLength; void *pData; void *pDataPtr; struct bucket *pListNext; struct bucket *pListLast; struct bucket *pNext; struct bucket *pLast; char arKey[1]; /* Must be last element */&#125; Bucket; typedef struct _hashtable &#123; uint nTableSize; uint nTableMask; uint nNumOfElements; ulong nNextFreeElement; Bucket *pInternalPointer; /* Used for element traversal */ Bucket *pListHead; Bucket *pListTail; Bucket **arBuckets; dtor_func_t pDestructor; zend_bool persistent; unsigned char nApplyCount; zend_bool bApplyProtection;#if ZEND_DEBUG int inconsistent;#endif&#125; HashTable; 字段名很清楚的表明其用途，因此不做过多解释。重点明确下面几个字段：Bucket中的“h”用于存储原始key；HashTable中的nTableMask是一个掩码，一般被设为nTableSize – 1，与哈希算法有密切关系，后面讨论哈希算法时会详述；arBuckets指向一个指针数组，其中每个元素是一个指向Bucket链表的头指针。 哈希算法PHP哈希表最小容量是8（2^3），最大容量是0×80000000（2^31），并向2的整数次幂圆整（即长度会自动扩展为2的整数次幂，如13个元素的哈希表长度为16；100个元素的哈希表长度为128）。nTableMask被初始化为哈希表长度（圆整后）减1。具体代码在zend/Zend_hash.c的_zend_hash_init函数中，这里截取与本文相关的部分并加上少量注释。123456789101112131415161718192021222324ZEND_API int _zend_hash_init(HashTable *ht, uint nSize, hash_func_t pHashFunction, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)&#123; uint i = 3; Bucket **tmp; SET_INCONSISTENT(HT_OK); //长度向2的整数次幂圆整 if (nSize &amp;gt;= 0x80000000) &#123; /* prevent overflow */ ht-&amp;gt;nTableSize = 0x80000000; &#125; else &#123; while ((1U &amp;lt;&amp;lt; i) &amp;lt; nSize) &#123; i++; &#125; ht-&amp;gt;nTableSize = 1 &amp;lt;&amp;lt; i; &#125; ht-&amp;gt;nTableMask = ht-&amp;gt;nTableSize - 1; /*此处省略若干代码…*/ return SUCCESS;&#125; 值得一提的是PHP向2的整数次幂取圆整方法非常巧妙，可以背下来在需要的时候使用。 Zend HashTable的哈希算法异常简单：即简单将数据的原始key与HashTable的nTableMask进行按位与即可。如果原始key为字符串，则首先使用Times33算法将字符串转为整形再与nTableMask按位与。下面是Zend源码中查找哈希表的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243ZEND_API int zend_hash_index_find(const HashTable *ht, ulong h, void **pData)&#123; uint nIndex; Bucket *p; IS_CONSISTENT(ht); nIndex = h &amp; ht-&gt;nTableMask; p = ht-&gt;arBuckets[nIndex]; while (p != NULL) &#123; if ((p-&gt;h == h) &amp;&amp; (p-&gt;nKeyLength == 0)) &#123; *pData = p-&gt;pData; return SUCCESS; &#125; p = p-&gt;pNext; &#125; return FAILURE;&#125;ZEND_API int zend_hash_find(const HashTable *ht, const char *arKey, uint nKeyLength, void **pData)&#123; ulong h; uint nIndex; Bucket *p; IS_CONSISTENT(ht); h = zend_inline_hash_func(arKey, nKeyLength); nIndex = h &amp; ht-&gt;nTableMask; p = ht-&gt;arBuckets[nIndex]; while (p != NULL) &#123; if ((p-&gt;h == h) &amp;&amp; (p-&gt;nKeyLength == nKeyLength)) &#123; if (!memcmp(p-&gt;arKey, arKey, nKeyLength)) &#123; *pData = p-&gt;pData; return SUCCESS; &#125; &#125; p = p-&gt;pNext; &#125; return FAILURE;&#125; 其中zend_hash_index_find用于查找整数key的情况，zend_hash_find用于查找字符串key。逻辑基本一致，只是字符串key会通过zend_inline_hash_func转为整数key，zend_inline_hash_func封装了times33算法，具体代码就不贴出了。 攻击基本攻击知道了PHP内部哈希表的算法，就可以利用其原理构造用于攻击的数据。一种最简单的方法是利用掩码规律制造碰撞。上文提到Zend HashTable的长度nTableSize会被圆整为2的整数次幂，假设我们构造一个2^16的哈希表，则nTableSize的二进制表示为：1 0000 0000 0000 0000，而nTableMask = nTableSize – 1为：0 1111 1111 1111 1111。接下来，可以以0为初始值，以2^16为步长，制造足够多的数据，可以得到如下推测： 0000 0000 0000 0000 0000 &amp; 0 1111 1111 1111 1111 = 0 0001 0000 0000 0000 0000 &amp; 0 1111 1111 1111 1111 = 0 0010 0000 0000 0000 0000 &amp; 0 1111 1111 1111 1111 = 0 0011 0000 0000 0000 0000 &amp; 0 1111 1111 1111 1111 = 0 0100 0000 0000 0000 0000 &amp; 0 1111 1111 1111 1111 = 0 …… 概况来说只要保证后16位均为0，则与掩码位于后得到的哈希值全部碰撞在位置0。 下面是利用这个原理写的一段攻击代码：12345678910111213&lt;?php$size = pow(2, 16); $startTime = microtime(true); $array = array();for ($key = 0, $maxKey = ($size - 1) * $size; $key &lt;= $maxKey; $key += $size) &#123; $array[$key] = 0;&#125; $endTime = microtime(true); echo $endTime - $startTime, ' seconds', \"\\n\"; 这段代码在我的VPS上（单CPU，512M内存）上用了近88秒才完成，并且在此期间CPU资源几乎被用尽：而普通的同样大小的哈希表插入仅用时0.036秒：1234567891011121314&lt;?php $size = pow(2, 16); $startTime = microtime(true); $array = array();for ($key = 0, $maxKey = ($size - 1) * $size; $key &lt;= $size; $key += 1) &#123; $array[$key] = 0;&#125; $endTime = microtime(true); echo $endTime - $startTime, ' seconds', \"\\n\"; 可以证明第二段代码插入N个元素的时间在O(N)水平，而第一段攻击代码则需O(N^2)的时间去插入N个元素。 POST攻击当然，一般情况下很难遇到攻击者可以直接修改PHP代码的情况，但是攻击者仍可以通过一些方法间接构造哈希表来进行攻击。例如PHP会将接收到的HTTP POST请求中的数据构造为$_POST，而这是一个Array，内部就是通过Zend HashTable表示，因此攻击者只要构造一个含有大量碰撞key的post请求，就可以达到攻击的目的。具体做法不再演示。 防护POST攻击的防护针对POST方式的哈希碰撞攻击，目前PHP的防护措施是控制POST数据的数量。在&gt;=PHP5.3.9的版本中增加了一个配置项max_input_vars，用于标识一次http请求最大接收的参数个数，默认为1000。因此PHP5.3.x的用户可以通过升级至5.3.9来避免哈希碰撞攻击。5.2.x的用户可以使用这个patch：http://www.laruence.com/2011/12/30/2440.html。 另外的防护方法是在Web服务器层面进行处理，例如限制http请求body的大小和参数的数量等，这个是现在用的最多的临时处理方案。具体做法与不同Web服务器相关，不再详述。 其它防护上面的防护方法只是限制POST数据的数量，而不能彻底解决这个问题。例如，如果某个POST字段是一个json数据类型，会被PHPjson_decode，那么只要构造一个超大的json攻击数据照样可以达到攻击目的。理论上，只要PHP代码中某处构造Array的数据依赖于外部输入，则都可能造成这个问题，因此彻底的解决方案要从Zend底层HashTable的实现动手。一般来说有两种方式，一是限制每个桶链表的最长长度；二是使用其它数据结构如红黑树取代链表组织碰撞哈希（并不解决哈希碰撞，只是减轻攻击影响，将N个数据的操作时间从O(N^2)降至O(NlogN)，代价是普通情况下接近O(1)的操作均变为O(logN)）。 目前使用最多的仍然是POST数据攻击，因此建议生产环境的PHP均进行升级或打补丁。至于从数据结构层面修复这个问题，目前还没有任何方面的消息。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.chenc.cc/tags/PHP/"},{"name":"哈希碰撞","slug":"哈希碰撞","permalink":"http://www.chenc.cc/tags/哈希碰撞/"}]}]