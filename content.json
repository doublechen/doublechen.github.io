[{"title":"《高性能MySQL》学习笔记之索引篇","date":"2017-08-15T06:09:14.000Z","path":"2017/08/15/mysql-table-design-index/","text":"索引类型(在存储引擎层实现)B-TREE索引所有的值都是按照顺序存储的，并且每个叶子节点到根节点的距离相同不再需要全表扫描，从索引根节点开始搜索到叶子节点，叶子节点指向被索引的数据排序中也可以用到 可使用B-TREE索引的查询类型 全值匹配 匹配最左前缀 匹配列前缀 匹配范围值 精确匹配某一列并范围匹配另一列 只访问索引的查询 限制 如果不是按照最左列开始查找则无法使用索引 不能跳过索引中的列 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引 哈希索引基于哈希表实现的索引，只有精确匹配所有列才能有效，查找极快 限制 哈希索引只包含哈希值和行指针，不存储字段值，需要回表读取行信息 哈希索引不是按照索引值顺序存储的，不能用于排序 不支持部分列查找 只能等值查找 可能有哈希冲突 冲突多时维护成本高 空间数据索引 R-TREEMYISAM中支持，可用作地理数据存储，无需前缀查询，必须使用MySQL的GIS相关函数来维护数据MySQL对此支持不完善 全文索引和其他没实际用处，可通过Lucene等实现 索引的优点 可以让服务器快速定位到表的指定位置 大大减少了服务器需要扫描的数据量 可以帮助服务器避免排序和临时表 可以将随机I/O 编程顺序I/O 高性能索引策略独立的列索引列不能是表达式的一部分，也不能是参数 1select aid from a where aid + 1 = 5 # 错误示例 前缀索引和索引的选择性前缀索引使用开始部分的字符来节约空间选多长前缀合适，可通过计算获得 先计算整表的选择性 1select count(distinct city) / count(*) from demo 再计算接近上述结果的长度 1select count(distinct left(city),3) / count(*) from demo 创建前缀索引 1alter table demo add key (city(3)) 选择合适的索引及列顺序在一个多列的b-tree索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列等等。所以，索引可以按照升序或降序进行扫描，以满足精确符合列顺序的order by，group by，distinct等子句的查询需求 法则:将选择性高的列放到索引最前列 聚集索引当表有聚集索引时，它的数据实际存放在叶子节点中一个表只能有一个聚集索引不是所有的存储引擎都支持聚集索引 聚集索引的创建 InnoDB 通过主键聚集数据 未定义主键 选择一个唯一的飞控索引代替 没有这样的索引 InnoDB 将隐士定义一个主键来代替 优点 可以把相关数据保存在一起 数据访问更快 使用覆盖索引扫描的查询可以直接使用叶节点中的键值 缺点 数据在内存中时，访问顺序不主要，优势消失 插入数据严重依赖插入顺序 更新聚集索引列代价高 移动位置 移动行时页分裂问题 全表扫描变慢 二级索引更大 二级索引要两次查找而不是一次 覆盖索引 一个索引包含所有需要查询的字段值（字段，条件，排序等），查询只需要扫描索引而无需回表 好处 减少数据访问量 顺序存储 io 少 对innodb表特别有用 MYSQL只能用B-TREE索引来做覆盖索引MySQL不能在索引中执行like操作 使用索引扫描来做排序MySQL获得有序结果的方式：排序操作或按照索引顺序扫描如果explain中 type：index 说明按照索引扫描排序 只有当索引列顺序和orderby子句顺序完全一致且所有列排序方向都一样的时候，MySQL才会用索引来排序 如果查询关联多张表，只有当orderby引用字段全部为第一张表时，才能用索引排序 最左前缀或前导列为常量 压缩索引MyISAM使用前缀压缩来减少索引大小，从而让更多的索引放入内存中压缩方法:先保存索引块中的第一个值，然后将其他值和第一个值进行比较，得到相同的字节数和生育的不同后缀部分如 perform performance =&gt; perform 7,ance不适用于io密集型应用","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.chenc.cc/tags/MySQL/"}]},{"title":"《高性能MySQL》学习笔记之数据类型篇","date":"2017-08-14T06:09:14.000Z","path":"2017/08/14/mysql-table-design-datatype/","text":"数据类型 整数类型 TINYINT,SMALLINT,MEDIUMINT,INT,BIGINT分别使用8，16，24，32，64位存储空间，存储的值范围为-2^(N-1)~2^(N-1)-1根据要存储的数据大小选择合适的整数类型UNSIGNED可选属性，表示不允许负值，只存非负整数相应地存储正数上限也大了一倍 实数类型 FLOAT,DOUBLE类型支持使用标准型的浮点运算进行近似计算DECIMAL用于存储精确的小数，数据量较大时建议使用BIGINT代替 DECIMAL，将需要存储的货币单位根据小数的位数乘以相应的倍数进行存储 VARCHAR,CHAR VARCHAR用于存储可变长字符串，它比定长字符串更节省空间，仅使用必要的空间。以下情况使用varchar是合适的：字符串列的最大长度比平均长度大很多；列的更新很少，所以碎片不是问题；使用像utf-8这样的复杂字符集，每个字符都使用不同的字节数进行存储。char类型的长度是定长的，适合存储很短的字符串，或者所有值都接近同一长度，经常变更的列等 BLOB,TEXT类型 BLOB,TEXT都是为存储很大的数据而设计的的字符串类型，分别采用二进制和文本方式存储。 ENUM枚举类型 MySQL在内部会将每个值在表中的位置保存为整数，且排序是按照对应的数字进行排序并不是按字符串不建议使用的类型 时间类型 DATATIME和TIMESTAMPDATATIM能保存大范围的值，从1001年到9999年精确到秒，与时区无关，使用8字节存储空间TIMESTAMP保存了从1970-01-01 00:00:00（格林尼治时间）以来的秒数，只用4字节存储空间，只能表示1970～2038年，与时区有关，会自动调整，除特殊行为之外尽量使用，因为其效率更高不要将unix时间戳作为整数存储到数据库，不好处理 优化数据类型 尽量使用可以正确存储数据的最小数据类型 占用更少的cpu、内存、磁盘等 尽量使用简单的数据类型 整型比字符串的操作代价更低应该使用mysql自建的数据类型来存储日期和时间应该用整型存储IP地址（32位无符号整数 inet_aton() inet_ntoa()） 尽量避免null 可为null的列使得索引、索引统计和值都更复杂，会占用更多的存储空间且需要mysql特殊处理","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.chenc.cc/tags/MySQL/"}]},{"title":"MySQL 插入时如果存在则更新","date":"2017-07-17T11:29:49.000Z","path":"2017/07/17/mysql-insert-or-update/","text":"SQL123INSERT INTO testable (a,b,c) VALUES (2,3,5),(7,6,7) ON DUPLICATE KEY UPDATE a=VALUES(a),b=VALUES(b),c=VALUES(c) 注意 要先添加唯一索引，MySQL根据唯一索引来判断是否重复 优点 效率高，判断当存在重复值时直接在当前行上更新，无需更新索引 问题 发现语句执行后即便没有插入数据表的自增主键还是进行了更新。 其他方法 replace 语法 SQL 1replace into testable (a, b, c) values(1, 2, 3),(11, 12, 13) MySQL 提供的语法 效率相比ON DUPLICATE KEY UPDATE 效率较低(因为他的操作方式是判断是否存在，存在则删除旧数据再插入新数据，删除和插入数据后都需更新索引，数据量较大的时候比较消耗性能)","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.chenc.cc/tags/MySQL/"},{"name":"程序员","slug":"程序员","permalink":"http://www.chenc.cc/tags/程序员/"}]},{"title":"北邮附近的好吃的！","date":"2017-06-07T08:29:49.000Z","path":"2017/06/07/food-around-bupt/","text":"有大神梳理了北邮附近的各种好吃的，从食堂到外卖，从小店到餐厅。。。这里偷懒直接截个图收藏了~","tags":[{"name":"好吃的","slug":"好吃的","permalink":"http://www.chenc.cc/tags/好吃的/"}]},{"title":"洗白白之后美美哒","date":"2017-06-07T08:11:51.000Z","path":"2017/06/07/golden-2017-06-07/","text":"","tags":[{"name":"金大毛","slug":"金大毛","permalink":"http://www.chenc.cc/tags/金大毛/"},{"name":"金毛嘟","slug":"金毛嘟","permalink":"http://www.chenc.cc/tags/金毛嘟/"}]},{"title":"PHP哈希表碰撞攻击原理","date":"2016-03-16T00:12:43.000Z","path":"2016/03/16/php-gc/","text":"转载自伯乐在线 哈希表碰撞攻击的基本原理哈希表是一种查找效率极高的数据结构，很多语言都在内部实现了哈希表。PHP中的哈希表是一种极为重要的数据结构，不但用于表示Array数据类型，还在Zend虚拟机内部用于存储上下文环境信息（执行上下文的变量及函数均使用哈希表结构存储）。理想情况下哈希表插入和查找操作的时间复杂度均为O(1)，任何一个数据项可以在一个与哈希表长度无关的时间内计算出一个哈希值（key），然后在常量时间内定位到一个桶（术语bucket，表示哈希表中的一个位置）。当然这是理想情况下，因为任何哈希表的长度都是有限的，所以一定存在不同的数据项具有相同哈希值的情况，此时不同数据项被定为到同一个桶，称为碰撞（collision）。哈希表的实现需要解决碰撞问题，碰撞解决大体有两种思路，第一种是根据某种原则将被碰撞数据定为到其它桶，例如线性探测——如果数据在插入时发生了碰撞，则顺序查找这个桶后面的桶，将其放入第一个没有被使用的桶；第二种策略是每个桶不是一个只能容纳单个数据项的位置，而是一个可容纳多个数据的数据结构（例如链表或红黑树），所有碰撞的数据以某种数据结构的形式组织起来。 不论使用了哪种碰撞解决策略，都导致插入和查找操作的时间复杂度不再是O(1)。以查找为例，不能通过key定位到桶就结束，必须还要比较原始key（即未做哈希之前的key）是否相等，如果不相等，则要使用与插入相同的算法继续查找，直到找到匹配的值或确认数据不在哈希表中。 PHP是使用单链表存储碰撞的数据，因此实际上PHP哈希表的平均查找复杂度为O(L)，其中L为桶链表的平均长度；而最坏复杂度为O(N)，此时所有数据全部碰撞，哈希表退化成单链表。下图PHP中正常哈希表和退化哈希表的示意图。哈希表碰撞攻击就是通过精心构造数据，使得所有数据全部碰撞，人为将哈希表变成一个退化的单链表，此时哈希表各种操作的时间均提升了一个数量级，因此会消耗大量CPU资源，导致系统无法快速响应请求，从而达到拒绝服务攻击（DoS）的目的。 可以看到，进行哈希碰撞攻击的前提是哈希算法特别容易找出碰撞，如果是MD5或者SHA1那基本就没戏了，幸运的是（也可以说不幸的是）大多数编程语言使用的哈希算法都十分简单（这是为了效率考虑），因此可以不费吹灰之力之力构造出攻击数据。下一节将通过分析Zend相关内核代码，找出攻击哈希表碰撞攻击PHP的方法。 Zend哈希表的内部实现数据结构PHP中使用一个叫Backet的结构体表示桶，同一哈希值的所有桶被组织为一个单链表。哈希表使用HashTable结构体表示。相关源码在zend/Zend_hash.h下：1234567891011121314151617181920212223242526272829typedef struct bucket &#123; ulong h; /* Used for numeric indexing */ uint nKeyLength; void *pData; void *pDataPtr; struct bucket *pListNext; struct bucket *pListLast; struct bucket *pNext; struct bucket *pLast; char arKey[1]; /* Must be last element */&#125; Bucket; typedef struct _hashtable &#123; uint nTableSize; uint nTableMask; uint nNumOfElements; ulong nNextFreeElement; Bucket *pInternalPointer; /* Used for element traversal */ Bucket *pListHead; Bucket *pListTail; Bucket **arBuckets; dtor_func_t pDestructor; zend_bool persistent; unsigned char nApplyCount; zend_bool bApplyProtection;#if ZEND_DEBUG int inconsistent;#endif&#125; HashTable; 字段名很清楚的表明其用途，因此不做过多解释。重点明确下面几个字段：Bucket中的“h”用于存储原始key；HashTable中的nTableMask是一个掩码，一般被设为nTableSize – 1，与哈希算法有密切关系，后面讨论哈希算法时会详述；arBuckets指向一个指针数组，其中每个元素是一个指向Bucket链表的头指针。 哈希算法PHP哈希表最小容量是8（2^3），最大容量是0×80000000（2^31），并向2的整数次幂圆整（即长度会自动扩展为2的整数次幂，如13个元素的哈希表长度为16；100个元素的哈希表长度为128）。nTableMask被初始化为哈希表长度（圆整后）减1。具体代码在zend/Zend_hash.c的_zend_hash_init函数中，这里截取与本文相关的部分并加上少量注释。123456789101112131415161718192021222324ZEND_API int _zend_hash_init(HashTable *ht, uint nSize, hash_func_t pHashFunction, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)&#123; uint i = 3; Bucket **tmp; SET_INCONSISTENT(HT_OK); //长度向2的整数次幂圆整 if (nSize &amp;gt;= 0x80000000) &#123; /* prevent overflow */ ht-&amp;gt;nTableSize = 0x80000000; &#125; else &#123; while ((1U &amp;lt;&amp;lt; i) &amp;lt; nSize) &#123; i++; &#125; ht-&amp;gt;nTableSize = 1 &amp;lt;&amp;lt; i; &#125; ht-&amp;gt;nTableMask = ht-&amp;gt;nTableSize - 1; /*此处省略若干代码…*/ return SUCCESS;&#125; 值得一提的是PHP向2的整数次幂取圆整方法非常巧妙，可以背下来在需要的时候使用。 Zend HashTable的哈希算法异常简单：即简单将数据的原始key与HashTable的nTableMask进行按位与即可。如果原始key为字符串，则首先使用Times33算法将字符串转为整形再与nTableMask按位与。下面是Zend源码中查找哈希表的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243ZEND_API int zend_hash_index_find(const HashTable *ht, ulong h, void **pData)&#123; uint nIndex; Bucket *p; IS_CONSISTENT(ht); nIndex = h &amp; ht-&gt;nTableMask; p = ht-&gt;arBuckets[nIndex]; while (p != NULL) &#123; if ((p-&gt;h == h) &amp;&amp; (p-&gt;nKeyLength == 0)) &#123; *pData = p-&gt;pData; return SUCCESS; &#125; p = p-&gt;pNext; &#125; return FAILURE;&#125;ZEND_API int zend_hash_find(const HashTable *ht, const char *arKey, uint nKeyLength, void **pData)&#123; ulong h; uint nIndex; Bucket *p; IS_CONSISTENT(ht); h = zend_inline_hash_func(arKey, nKeyLength); nIndex = h &amp; ht-&gt;nTableMask; p = ht-&gt;arBuckets[nIndex]; while (p != NULL) &#123; if ((p-&gt;h == h) &amp;&amp; (p-&gt;nKeyLength == nKeyLength)) &#123; if (!memcmp(p-&gt;arKey, arKey, nKeyLength)) &#123; *pData = p-&gt;pData; return SUCCESS; &#125; &#125; p = p-&gt;pNext; &#125; return FAILURE;&#125; 其中zend_hash_index_find用于查找整数key的情况，zend_hash_find用于查找字符串key。逻辑基本一致，只是字符串key会通过zend_inline_hash_func转为整数key，zend_inline_hash_func封装了times33算法，具体代码就不贴出了。 攻击基本攻击知道了PHP内部哈希表的算法，就可以利用其原理构造用于攻击的数据。一种最简单的方法是利用掩码规律制造碰撞。上文提到Zend HashTable的长度nTableSize会被圆整为2的整数次幂，假设我们构造一个2^16的哈希表，则nTableSize的二进制表示为：1 0000 0000 0000 0000，而nTableMask = nTableSize – 1为：0 1111 1111 1111 1111。接下来，可以以0为初始值，以2^16为步长，制造足够多的数据，可以得到如下推测： 0000 0000 0000 0000 0000 &amp; 0 1111 1111 1111 1111 = 0 0001 0000 0000 0000 0000 &amp; 0 1111 1111 1111 1111 = 0 0010 0000 0000 0000 0000 &amp; 0 1111 1111 1111 1111 = 0 0011 0000 0000 0000 0000 &amp; 0 1111 1111 1111 1111 = 0 0100 0000 0000 0000 0000 &amp; 0 1111 1111 1111 1111 = 0 …… 概况来说只要保证后16位均为0，则与掩码位于后得到的哈希值全部碰撞在位置0。 下面是利用这个原理写的一段攻击代码：12345678910111213&lt;?php$size = pow(2, 16); $startTime = microtime(true); $array = array();for ($key = 0, $maxKey = ($size - 1) * $size; $key &lt;= $maxKey; $key += $size) &#123; $array[$key] = 0;&#125; $endTime = microtime(true); echo $endTime - $startTime, ' seconds', \"\\n\"; 这段代码在我的VPS上（单CPU，512M内存）上用了近88秒才完成，并且在此期间CPU资源几乎被用尽：而普通的同样大小的哈希表插入仅用时0.036秒：1234567891011121314&lt;?php $size = pow(2, 16); $startTime = microtime(true); $array = array();for ($key = 0, $maxKey = ($size - 1) * $size; $key &lt;= $size; $key += 1) &#123; $array[$key] = 0;&#125; $endTime = microtime(true); echo $endTime - $startTime, ' seconds', \"\\n\"; 可以证明第二段代码插入N个元素的时间在O(N)水平，而第一段攻击代码则需O(N^2)的时间去插入N个元素。 POST攻击当然，一般情况下很难遇到攻击者可以直接修改PHP代码的情况，但是攻击者仍可以通过一些方法间接构造哈希表来进行攻击。例如PHP会将接收到的HTTP POST请求中的数据构造为$_POST，而这是一个Array，内部就是通过Zend HashTable表示，因此攻击者只要构造一个含有大量碰撞key的post请求，就可以达到攻击的目的。具体做法不再演示。 防护POST攻击的防护针对POST方式的哈希碰撞攻击，目前PHP的防护措施是控制POST数据的数量。在&gt;=PHP5.3.9的版本中增加了一个配置项max_input_vars，用于标识一次http请求最大接收的参数个数，默认为1000。因此PHP5.3.x的用户可以通过升级至5.3.9来避免哈希碰撞攻击。5.2.x的用户可以使用这个patch：http://www.laruence.com/2011/12/30/2440.html。 另外的防护方法是在Web服务器层面进行处理，例如限制http请求body的大小和参数的数量等，这个是现在用的最多的临时处理方案。具体做法与不同Web服务器相关，不再详述。 其它防护上面的防护方法只是限制POST数据的数量，而不能彻底解决这个问题。例如，如果某个POST字段是一个json数据类型，会被PHPjson_decode，那么只要构造一个超大的json攻击数据照样可以达到攻击目的。理论上，只要PHP代码中某处构造Array的数据依赖于外部输入，则都可能造成这个问题，因此彻底的解决方案要从Zend底层HashTable的实现动手。一般来说有两种方式，一是限制每个桶链表的最长长度；二是使用其它数据结构如红黑树取代链表组织碰撞哈希（并不解决哈希碰撞，只是减轻攻击影响，将N个数据的操作时间从O(N^2)降至O(NlogN)，代价是普通情况下接近O(1)的操作均变为O(logN)）。 目前使用最多的仍然是POST数据攻击，因此建议生产环境的PHP均进行升级或打补丁。至于从数据结构层面修复这个问题，目前还没有任何方面的消息。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.chenc.cc/tags/PHP/"},{"name":"哈希碰撞","slug":"哈希碰撞","permalink":"http://www.chenc.cc/tags/哈希碰撞/"}]}]