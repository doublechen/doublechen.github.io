[{"title":"MySQL分区表","date":"2017-11-01T11:09:49.000Z","path":"2017/11/01/MySQL/mysql-partation/","text":"分区表对用户来说分区表是一个独立的逻辑表，但是底层由多个物理子表组成。实现分区的代码实际上是对一组底层表的句柄对象的封装。对分区表的请求，都会通过句柄对象转化成对存储引擎的接口的调用。所以分区表对于SQL层来说是一个完全封装底层实现的黑盒子，对应用是透明的，但是从底层的文件系统看来就很容易发现，每一个分区表都有一个使用 # 分隔命名的表文件。MySQL实现分区表的方式(对底层的封装)意味着索引也是按照分区的子表定义的，而没有全局索引。MySQL在创建表时使用 PARTITION BY 子句定义每个分区存放的数据。在执行查询是，优化器会根据分区定义过滤那些没有我们需要数据的分区，这样查询就无须扫描所有分区，只需要查询包含数据的分区。分区的一个主要目的就是将数据按照一个较粗的粒度分在不同的表中。 分区表适用的场景 表非常大以至于无法全部放进内存中，或者只在表的最后部分有热点数据，其他均是历史数据 分区表的数据更容易维护。可批量删除整个分区，还可以对一个独立的分区进行优化检查修复等操作 分区表的数据还可以放在不同的物理设备上 可以使用分区表避免某些特殊的瓶颈，例如innodb的单个索引的互斥访问、ext3文件系统的iNode锁竞争等 如果需要，还可以备份和恢复独立的分区，大数据集场景下效果好 分区表的限制 一个表最多有1024个分区 在MySQL5.1中分区表达式必须是整数，或返回整数的表达式。在MySQL5.5中，某些场景下可以直接使用列来分区 如果分区字段中有主键或唯一索引的列，那么所有主键列和唯一索引列都必须包含进来。 分区表中无法使用外键约束。 分区表上的操作 SELECT查询 当插查询一个分区表的时候，分区层先打开并锁住所有的底层表，优化器先判断是否可以过滤部分分区，然后再调用对应的存储引擎接口访问各分区数据 INSERT操作 当写入一条记录时，分区层先打开并锁住所有底层表，然后确定那个分区接收这条记录，再讲记录写入对应的底层表 DELETE操作 当删除一条记录时，分区层先打开并锁住所有底层表，然后确定数据对应的分区，最后将数据从对应底层表删除 UPDATE操作 当更新一条记录时，分区层先打开并锁住所有底层表，MySQL先确定要更新的数据在哪个分区，然后取出数据并更新，再判断更新后的数据应该放在哪个分区，最后写入底层表，并对原数据进行删除操作 虽然每个操作都会“先打开并锁住所有的底层表”，但是并不是说分区表在处理过程中是锁住全表的。如果存储引擎能够自己实现行级锁，例如innodb,则会在分区层释放对应表锁。 分区表类型 根据范围进行分区 根据键值分区 哈希分区 列表分区 如何使用分区表数据量超大时，B-Tree索引就无法起作用了。除非是索引覆盖查询，否则数据库服务器需要根据索引扫描的结果回表，查询所有符合条件的记录，如果数据量巨大，将产生大量的随机I/O，随之，数据库响应时间将大大增长。另外，索引维护(磁盘空间，I/O)的代价也非常高。 为保证大数据量下的可扩展性，一般有下面两个策略 全量扫描数据，不需要任何索引 可以使用简单的分区方式存放表，不需要任何索引，根据分区的规则大致定位需要的数据位置。只要where条件能将需要的数据定位在少数分区中，则效率是高的。适用于以正常的方式访问大量数据。必须将查询需要扫描的分区个数限制在一个很小的数量。 索引数据，并分离热点 如果数据有明显的“热点”，而且除了这部分数据，其他数据很少被访问到，那么可以将这部分热点数据单独放在一个分区中，让这部分数据可以缓存在内存中。这样查询就可以只访问一个很小的分区表，能够使用索引，也能够有效的使用缓存。 可能会出现的问题 NULL值会使分区过滤无效 分区表的第一个分区是一个特殊分区。假设按照PARTITION BY RANGE YEAR(order_date)分区，那么所有order_date为NULL或者非法值的时候，记录都会被存放到第一个分区。查询时，WHERE order_date BETWEEN &#39;2012-01-01&#39; AND &#39;2012-01-31&#39;，就会查询两个分区，2012这个分区和第一个分区。如果第一个分区非常大的时候，特别是使用全表扫描无索引的时候代价就会非常大。为避免这种情况可以创建一个无用的第一个分区PARTITION p_null VALUES LESS THAN (0)。在MySQL5.5中则可以直接使用列本身而不是基于列的函数进行分区：PARTITION BY RANGE COLUMNS(order_date) 分区列和索引列不匹配 如果定义的分区列和索引列不匹配，会导致查询无法进行分区过滤。假设在a上定义了索引，而在列b上进行分区。因为每个分区都有其独立的索引，所以扫描列b上的索引就需要扫描每一个分区内对应的索引。应该避免建立和分区列不匹配的索引，除非查询中还同时包含了可以过滤分区的条件。 选择分区的成本可能很高 当范围分区时，增删改查数据时都需要定位数据所在的分区，当分区过多时线性搜索效率不高。减少分区数量，对大多数系统，100个左右分区是没有问题的。键分区、哈希分区等不存在该问题 打开并锁住所有底层表的成本可能更高 当查询访问分区表的时候，MySQL需要打开并锁住所有的底层表，这是分区表的另一个开销。这个操作在过滤之前发生，所以我发通过分区过滤降低此开销，且和分区类型无关，会影响所有查询。 维护分区的成本可能很高 新增删除分区可能会很快，但是需要移动数据的操作就会很慢 分区的限制 所有分区都必须使用相同的存储引擎 分区函数中可以使用的函数和表达式也有一些限制 某些存储引擎不支持分区 查询优化在where条件中带入分区列，不能根据表达式的值去过滤分区，和索引类似，列上也不可以使用函数。","tags":[{"name":"程序员","slug":"程序员","permalink":"http://www.chenc.cc/tags/程序员/"},{"name":"MySQL","slug":"MySQL","permalink":"http://www.chenc.cc/tags/MySQL/"}]},{"title":"在七牛云上部署Hexo","date":"2017-09-12T15:22:41.000Z","path":"2017/09/12/blog/hexo-to-7cloud/","text":"Hexo是一款简单高效的基于nodejs的博客框架，很多程序员喜欢将它托管到GitHub Page使用。但是一直以来，GitHub在国内的访问速度都饱受诟病，所以最近笔者盯上了国内的对象存储产品。今天介绍一下如何在七牛云存储这个产品上部署hexo博客。从七牛云的官网报价来看，它的对象存储的标准存储产品在各地区服务器的存储空间费用在数据量为0-10G时是免费的，上传流量免费，GET请求在0-100W次范围内是免费的。融合CDN HTTP 下载流量每月0-10G也是免费的。这样的收费标准下部署个人博客应该是基本不用缴纳额外费用的。 注册账号首先需要一个七牛云账号。可以点击这个链接进行注册。注册成功后需要进行邮箱和实名制认证。按照引导操作即可。 创建存储空间进入控制台，新建存储空间，填写好存储空间名称、选择就近的存储区域、访问控制设置为公开即可。 创建好存储空间后，系统会分配给你一个测试域名，你可以用来测试访问自己的文件，但是需要注意的是此类测试域名，限总流量，限单 IP 访问频率，限速，仅供测试使用，不能用于自定义域名的 CNAME。你还需要绑定一个自己的域名 填写好域名(需要ICP备案过的域名) 设置好缓存策略(html文件尽量不缓存)，创建即可。 创建好了之后，又会分配给你一个域名，这个域名并不能直接访问，你需要把你的域名CNAME到这个域名。 对象存储设置到这里就基本完成了。 上传文件bucket设置好之后就需要把自己的静态文件上传到bucket中。这里推荐一个官方的上传工具 qshell，可以使你直接通过命令行上传文件。 下载好之后将其加入系统PATH，这样你可以全局使用qshell命令。 设置密钥使用命令单用户模式：1$ qshell account ak sk 多用户模式：1$ qshell -m account ak sk 设置密钥，密钥在个人面板中。 配置12345678910111213141516171819202122&#123; \"src_dir\" : \"/workspace/hexobolg/public/\", // 要同步的目录，一般是hexo的public目录 \"bucket\" : \"hexo-chenc-cc\", // bucket \"file_list\" : \"\", \"key_prefix\" : \"\", \"up_host\" : \"\", \"ignore_dir\" : false, \"overwrite\" : true, // 时候覆盖更新，一定要配置成true，不然你的index永远不会更新了 \"check_exists\" : true, \"check_hash\" : true, \"check_size\" : false, \"rescan_local\" : true, \"skip_file_prefixes\" : \"test,demo,\", \"skip_path_prefixes\" : \"hello/,temp/\", \"skip_fixed_strings\" : \".svn,.git\", \"skip_suffixes\" : \".DS_Store,.exe\", \"log_file\" : \"upload.log\", \"log_level\" : \"info\", \"log_rotate\" : 1, \"log_stdout\" : false, \"file_type\" : 0&#125; 将以上配置存储为json文件，作为命令的参数。 使用写好博客后可使用1$ hexo generate 生成静态文件，文件会生成在public目录下。然后通过qshell命令代替原有的hexo deploy命令将整个public目录上传到bucket即可完成发布。 1$ qshell qupload 7cloud.json 注:qshell还有许多其他的命令，这里不做阐述，使用时请查看qshell文档。","tags":[{"name":"博客","slug":"博客","permalink":"http://www.chenc.cc/tags/博客/"},{"name":"Hexo","slug":"Hexo","permalink":"http://www.chenc.cc/tags/Hexo/"}]},{"title":"最近学做的好吃的","date":"2017-09-07T08:29:49.000Z","path":"2017/09/07/cooking/cooking-chenc-20170910/","text":"离职在家休息这段时间学了学做饭，照猫画虎还不算难吃。。 香蒜虾焖饭 做法: 处理虾，去虾头，挑虾线 开火，加食用油，煸炒虾头，挤出虾油，加适量料酒，加水、盐，大火熬制高汤，大约10分钟后筛出虾头，高汤出锅备用 取虾仁，切段，加入料酒、盐、白胡椒腌制备用 大米淘洗后沥干备用 开火，加食用油，葱花炒香，加入胡萝卜丁、洋葱丁、蒜末翻炒片刻，加入沥干的大米翻炒出锅，倒入砂锅(电饭锅也行，砂锅容易糊锅) 砂锅加入生抽、豌豆粒，小火焖15分钟 开火，加食用油，蒜末炒香，加入虾段煸炒，盛出备用 米饭熟后加入虾段即可 红烧肉 做法: 五花肉切块，冷水下锅焯水，盛出洗净备用 冷锅冷油，冰糖30g小火炒出焦糖色，放入开水 肉块下锅，1勺老抽、2勺生抽、4勺黄酒、生姜5片、山楂若干，加开水没过五花肉(水要加够)，加盖小火1小时，大火收汁出锅 砂锅牛肉 做法: 牛肉(腱子肉)切块，清水浸泡1小时，浸泡出血水 开火，食用油，放入葱姜段大料煸炒出香味 加入牛肉翻炒1-2分钟，加两勺料酒两勺醋 原汤牛肉倒入砂锅，适量开水、山楂，水一次性加够，炖1小时，开锅后转小火 肉口感OK后可加入土豆胡萝卜块，1勺老抽、2勺生抽、1勺白糖、番茄酱、黑胡椒，再炖30分钟 大火收汁，加入彩椒翻炒出锅 糖醋虾 做法: 虾去虾线，备用 开火，食用油，加入大量葱丝、姜丝煸香，加入处理后的虾煸炒，煸炒变红后加入番茄酱、白糖，大火翻炒炒匀后出锅即可 汆丸子 做法: 肉馅，加葱花姜末，一个鸡蛋搅拌 少量多次加入清水，每次加水都沿同一方向搅拌直至水分完全吸收 加入鸡精、生抽、盐、胡椒粉，搅拌均匀入味 烧水，开锅后用虎口挤丸子下锅 撇净浮沫，加盐、鸡精、香油调味，撒上香菜出锅即可","tags":[{"name":"好吃的","slug":"好吃的","permalink":"http://www.chenc.cc/tags/好吃的/"},{"name":"香蒜虾焖饭","slug":"香蒜虾焖饭","permalink":"http://www.chenc.cc/tags/香蒜虾焖饭/"},{"name":"汆丸子","slug":"汆丸子","permalink":"http://www.chenc.cc/tags/汆丸子/"},{"name":"红烧肉","slug":"红烧肉","permalink":"http://www.chenc.cc/tags/红烧肉/"},{"name":"糖醋虾","slug":"糖醋虾","permalink":"http://www.chenc.cc/tags/糖醋虾/"},{"name":"砂锅牛肉","slug":"砂锅牛肉","permalink":"http://www.chenc.cc/tags/砂锅牛肉/"}]},{"title":"《高性能MySQL》学习笔记之索引篇","date":"2017-08-15T06:09:14.000Z","path":"2017/08/15/MySQL/mysql-table-design-index/","text":"索引类型(在存储引擎层实现)B-TREE索引所有的值都是按照顺序存储的，并且每个叶子节点到根节点的距离相同不再需要全表扫描，从索引根节点开始搜索到叶子节点，叶子节点指向被索引的数据排序中也可以用到 可使用B-TREE索引的查询类型 全值匹配 匹配最左前缀 匹配列前缀 匹配范围值 精确匹配某一列并范围匹配另一列 只访问索引的查询 限制 如果不是按照最左列开始查找则无法使用索引 不能跳过索引中的列 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引 哈希索引基于哈希表实现的索引，只有精确匹配所有列才能有效，查找极快 限制 哈希索引只包含哈希值和行指针，不存储字段值，需要回表读取行信息 哈希索引不是按照索引值顺序存储的，不能用于排序 不支持部分列查找 只能等值查找 可能有哈希冲突 冲突多时维护成本高 空间数据索引 R-TREEMYISAM中支持，可用作地理数据存储，无需前缀查询，必须使用MySQL的GIS相关函数来维护数据MySQL对此支持不完善 全文索引和其他没实际用处，可通过Lucene等实现 索引的优点 可以让服务器快速定位到表的指定位置 大大减少了服务器需要扫描的数据量 可以帮助服务器避免排序和临时表 可以将随机I/O 编程顺序I/O 高性能索引策略独立的列索引列不能是表达式的一部分，也不能是参数 1select aid from a where aid + 1 = 5 # 错误示例 前缀索引和索引的选择性前缀索引使用开始部分的字符来节约空间选多长前缀合适，可通过计算获得 先计算整表的选择性 1select count(distinct city) / count(*) from demo 再计算接近上述结果的长度 1select count(distinct left(city,3)) / count(*) from demo 创建前缀索引 1alter table demo add key (city(3)) 选择合适的索引及列顺序在一个多列的b-tree索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列等等。所以，索引可以按照升序或降序进行扫描，以满足精确符合列顺序的order by，group by，distinct等子句的查询需求 法则:将选择性高的列放到索引最前列 聚集索引当表有聚集索引时，它的数据实际存放在叶子节点中一个表只能有一个聚集索引不是所有的存储引擎都支持聚集索引 聚集索引的创建 InnoDB 通过主键聚集数据 未定义主键 选择一个唯一的非空索引代替 没有这样的索引 InnoDB 将隐式定义一个主键来代替 优点 可以把相关数据保存在一起 数据访问更快 使用覆盖索引扫描的查询可以直接使用叶节点中的键值 缺点 数据在内存中时，访问顺序不主要，优势消失 插入数据严重依赖插入顺序 更新聚集索引列代价高 移动位置 移动行时页分裂问题 全表扫描变慢 二级索引更大 二级索引要两次查找而不是一次 覆盖索引 一个索引包含所有需要查询的字段值（字段，条件，排序等），查询只需要扫描索引而无需回表 好处 减少数据访问量 顺序存储 io 少 对innodb表特别有用 MYSQL只能用B-TREE索引来做覆盖索引MySQL不能在索引中执行like操作 使用索引扫描来做排序MySQL获得有序结果的方式：排序操作或按照索引顺序扫描如果explain中 type：index 说明按照索引扫描排序 只有当索引列顺序和orderby子句顺序完全一致且所有列排序方向都一样的时候，MySQL才会用索引来排序 如果查询关联多张表，只有当orderby引用字段全部为第一张表时，才能用索引排序 最左前缀或前导列为常量 压缩索引MyISAM使用前缀压缩来减少索引大小，从而让更多的索引放入内存中压缩方法:先保存索引块中的第一个值，然后将其他值和第一个值进行比较，得到相同的字节数和生育的不同后缀部分如 perform performance =&gt; perform 7,ance不适用于io密集型应用","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.chenc.cc/tags/MySQL/"}]},{"title":"《高性能MySQL》学习笔记之数据类型篇","date":"2017-08-14T06:09:14.000Z","path":"2017/08/14/MySQL/mysql-table-design-datatype/","text":"数据类型 整数类型 TINYINT,SMALLINT,MEDIUMINT,INT,BIGINT分别使用8，16，24，32，64位存储空间，存储的值范围为-2^(N-1)~2^(N-1)-1根据要存储的数据大小选择合适的整数类型UNSIGNED可选属性，表示不允许负值，只存非负整数相应地存储正数上限也大了一倍 实数类型 FLOAT,DOUBLE类型支持使用标准型的浮点运算进行近似计算DECIMAL用于存储精确的小数，数据量较大时建议使用BIGINT代替 DECIMAL，将需要存储的货币单位根据小数的位数乘以相应的倍数进行存储 VARCHAR,CHAR VARCHAR用于存储可变长字符串，它比定长字符串更节省空间，仅使用必要的空间。以下情况使用varchar是合适的：字符串列的最大长度比平均长度大很多；列的更新很少，所以碎片不是问题；使用像utf-8这样的复杂字符集，每个字符都使用不同的字节数进行存储。char类型的长度是定长的，适合存储很短的字符串，或者所有值都接近同一长度，经常变更的列等 BLOB,TEXT类型 BLOB,TEXT都是为存储很大的数据而设计的的字符串类型，分别采用二进制和文本方式存储。 ENUM枚举类型 MySQL在内部会将每个值在表中的位置保存为整数，且排序是按照对应的数字进行排序并不是按字符串不建议使用的类型 时间类型 DATATIME和TIMESTAMPDATATIM能保存大范围的值，从1001年到9999年精确到秒，与时区无关，使用8字节存储空间TIMESTAMP保存了从1970-01-01 00:00:00（格林尼治时间）以来的秒数，只用4字节存储空间，只能表示1970～2038年，与时区有关，会自动调整，除特殊行为之外尽量使用，因为其效率更高不要将unix时间戳作为整数存储到数据库，不好处理 优化数据类型 尽量使用可以正确存储数据的最小数据类型 占用更少的cpu、内存、磁盘等 尽量使用简单的数据类型 整型比字符串的操作代价更低应该使用mysql自建的数据类型来存储日期和时间应该用整型存储IP地址（32位无符号整数 inet_aton() inet_ntoa()） 尽量避免null 可为null的列使得索引、索引统计和值都更复杂，会占用更多的存储空间且需要mysql特殊处理","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.chenc.cc/tags/MySQL/"}]},{"title":"MySQL 插入时如果存在则更新","date":"2017-07-17T11:29:49.000Z","path":"2017/07/17/MySQL/mysql-insert-or-update/","text":"SQL123INSERT INTO testable (a,b,c) VALUES (2,3,5),(7,6,7) ON DUPLICATE KEY UPDATE a=VALUES(a),b=VALUES(b),c=VALUES(c) 注意 要先添加唯一索引，MySQL根据唯一索引来判断是否重复 优点 效率高，判断当存在重复值时直接在当前行上更新，无需更新索引 问题 发现语句执行后即便没有插入数据表的自增主键还是进行了更新。 其他方法 replace 语法 SQL 1replace into testable (a, b, c) values(1, 2, 3),(11, 12, 13) MySQL 提供的语法 效率相比ON DUPLICATE KEY UPDATE 效率较低(因为他的操作方式是判断是否存在，存在则删除旧数据再插入新数据，删除和插入数据后都需更新索引，数据量较大的时候比较消耗性能) ThinkPHP3.2 中的应用 使用方法 【Exp：实现统计用户每天登陆次数的功能】 数据表 12345678CREATE TABLE `user_login_log` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `uid` varchar(10) NOT NULL, `date` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '统计日期', `nums` smallint(5) unsigned NOT NULL DEFAULT '0' COMMENT '统计数', PRIMARY KEY (`id`), UNIQUE KEY `uid-date` (`uid`,`date`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 ThinkPHP 中的用法 123456789101112$data = [ 'uid' =&gt; 1, 'date' =&gt; date('Y-m-d'), 'nums' =&gt; 1,];$update_data = array_merge($data, ['nums' =&gt; ['exp', 'nums + 1']]);// ON DUPLICATE KEY UPDATE方式M('user_login_log')-&gt;add($data, [], $update_data);// replace 方式M('user_login_log')-&gt;add($update_data, [], true); 分析 /ThinkPHP/Library/Think/Model.class.php源码中的add()方法接收3个参数，其中第三个参数控制了是否更新，以及以何种方式更新 12345678910public function add($data = '', $options = array(), $replace = false)&#123; #some code ... $result = $this-&gt;db-&gt;insert($data, $options, $replace); # some code ... return $result;&#125; add()方法中调用了/ThinkPHP/Library/Db/Driver.class.php抽象类中的insert()方法 123456789101112131415public function insert($data, $options = [], $replace = false)&#123; #some code ... // 兼容数字传入方式 $replace = (is_numeric($replace) &amp;&amp; $replace &gt; 0) ? true : $replace; $sql = $this-&gt;parseComment(!empty($options['comment']) ? $options['comment'] : ''); $sql .= (true === $replace ? 'REPLACE' : 'INSERT') . ' INTO ' . $this-&gt;parseTable( $options['table'] ) . ' (' . implode(',', $fields) . ') VALUES (' . implode(',', $values) . ')' . $this-&gt;parseDuplicate( $replace ); return $this-&gt;execute($sql, !empty($options['fetch_sql']) ? true : false);&#125; 可见insert()方法中根据$replace参数的类型选择了不同的更新方式，当传入的$replace参数为true或者大于0的数字的时候，选择以replace into的方式进行更新，当传入的$replace为其他参数时会调用parseDuplicate()方法对参数进行进一步解析，对于MySQL数据库parseDuplicate()方法在 /ThinkPHP/Library/Think/Db/Driver/Mysql.class.php类中进行了实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748protected function parseDuplicate($duplicate)&#123; // 布尔值或空则返回空字符串 if (is_bool($duplicate) || empty($duplicate)) &#123; return ''; &#125; if (is_string($duplicate)) &#123; // field1,field2 转数组 $duplicate = explode(',', $duplicate); &#125; elseif (is_object($duplicate)) &#123; // 对象转数组 $duplicate = get_class_vars($duplicate); &#125; $updates = array(); foreach ((array) $duplicate as $key =&gt; $val) &#123; if (is_numeric($key)) &#123; // array('field1', 'field2', 'field3') 解析为 ON DUPLICATE KEY UPDATE field1=VALUES(field1), field2=VALUES(field2), field3=VALUES(field3) $updates[] = $this-&gt;parseKey($val) . \"=VALUES(\" . $this-&gt;parseKey($val) . \")\"; &#125; else &#123; if (is_scalar($val)) // 兼容标量传值方式 &#123; $val = array('value', $val); &#125; if (!isset($val[1]) &amp;&amp; !is_null($val[1])) &#123; continue; &#125; switch ($val[0]) &#123; case 'exp': // 表达式 $updates[] = $this-&gt;parseKey($key) . \"=($val[1])\"; break; case 'value':// 值 default: $name = count($this-&gt;bind); $updates[] = $this-&gt;parseKey($key) . \"=:\" . $name; $this-&gt;bindParam($name, $val[1]); break; &#125; &#125; &#125; if (empty($updates)) &#123; return ''; &#125; return \" ON DUPLICATE KEY UPDATE \" . join(', ', $updates);&#125; 可见传入非空字符串或数组时采用了ON DUPLICATE KEY UPDATE的方式进行更新","tags":[{"name":"程序员","slug":"程序员","permalink":"http://www.chenc.cc/tags/程序员/"},{"name":"MySQL","slug":"MySQL","permalink":"http://www.chenc.cc/tags/MySQL/"}]},{"title":"Memcached::cas 乐观锁","date":"2017-06-10T11:03:14.000Z","path":"2017/06/10/PHP/php-memcached-cas/","text":"说明1public bool Memcached::cas ( float $cas_token , string $key , mixed $value [, int $expiration ] ) Memcached::cas()执行一个“检查并设置”的操作，因此，它仅在当前客户端最后一次取值后，该key 对应的值没有被其他客户端修改的情况下， 才能够将值写入。检查是通过cas_token参数进行的，这个参数是Memcach指定给已经存在的元素的一个唯一的64位值， 怎样获取这个值请查看Memcached::get*()系列方法的文档。注意：这个值作为double类型是因为PHP的整型空间限制。当该key被其他客户端更新后，cas_token将被更新，写入时将判断读取时获取的cas_token与当前cas_token是否一致，不一致则拒绝更新。 译注：这是Memcached扩展比Memcache扩展一个非常重要的优势， 在这样一个系统级（Memcache自身提供）的冲突检测机制（乐观锁）下， 我们才能保证高并发下的数据安全。 参数 cas_token与已存在元素关联的唯一的值，由Memcache生成。 key用于存储值的键名。 value存储的值。 expiration到期时间，默认为 0。 更多信息请参见到期时间。 返回值成功时返回 TRUE， 或者在失败时返回 FALSE。 如果在元素尝试存储时发现在本客户端最后一次获取后被其他客户端修改，Memcached::getResultCode() 将返回 Memcached::RES_DATA_EXISTS。 范例12345678910111213141516171819&lt;?php$m = new Memcached();$m-&gt;addServer('localhost', 11211);do &#123; /* 获取ip列表以及它的标记 */ $ips = $m-&gt;get('ip_block', null, $cas); /* 如果列表不存在， 创建并进行一个原子添加（如果其他客户端已经添加， 这里就返回false）*/ if ($m-&gt;getResultCode() == Memcached::RES_NOTFOUND) &#123; $ips = array($_SERVER['REMOTE_ADDR']); $m-&gt;add('ip_block', $ips); /* 其他情况下，添加ip到列表中， 并以cas方式去存储， 这样当其他客户端修改过， 则返回false */ &#125; else &#123; $ips[] = $_SERVER['REMOTE_ADDR']; $m-&gt;cas($cas, 'ip_block', $ips); &#125; &#125; while ($m-&gt;getResultCode() != Memcached::RES_SUCCESS);?&gt;","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.chenc.cc/tags/PHP/"},{"name":"Memcached","slug":"Memcached","permalink":"http://www.chenc.cc/tags/Memcached/"}]},{"title":"北邮附近的好吃的！","date":"2017-06-07T08:29:49.000Z","path":"2017/06/07/cooking/food-around-bupt/","text":"有大神梳理了北邮附近的各种好吃的，从食堂到外卖，从小店到餐厅。。。这里偷懒直接截个图收藏了~","tags":[{"name":"好吃的","slug":"好吃的","permalink":"http://www.chenc.cc/tags/好吃的/"}]},{"title":"【多图】家有美女初长成","date":"2017-06-07T08:11:51.000Z","path":"2017/06/07/golden/golden-2017-06-07/","text":"【多图】家有美女初长成","tags":[{"name":"金大毛","slug":"金大毛","permalink":"http://www.chenc.cc/tags/金大毛/"},{"name":"金毛嘟","slug":"金毛嘟","permalink":"http://www.chenc.cc/tags/金毛嘟/"}]},{"title":"TiUP技术分享--Git的基本命令和工作流简介","date":"2017-05-12T12:32:12.000Z","path":"2017/05/12/salon/tiup-salon-git/","text":"今天在团队技术沙龙主讲了Git的基本命令和工作流简介的相关内容，现将讲稿发到这里，供大家参考","tags":[{"name":"Git","slug":"Git","permalink":"http://www.chenc.cc/tags/Git/"},{"name":"技术沙龙","slug":"技术沙龙","permalink":"http://www.chenc.cc/tags/技术沙龙/"}]},{"title":"正则表达式学习笔记","date":"2017-05-10T11:01:12.000Z","path":"2017/05/10/PHP/regexp-notes/","text":"元字符 代码 说明 . 匹配除换行符以外的任意字符 \\w 匹配字母或数字或下划线或汉字 \\s 匹配任意的空白符 \\d 匹配数字 \\b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 字符转义\\转义 重复 代码/语法 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 字符类方括号里列出，像[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!) 分枝条件| 分隔整个表达式，表示或的关系 分组用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作 反义 代码/语法 说明 \\W 匹配任意不是字母，数字，下划线，汉字的字符 \\S 匹配任意不是空白符的字符 \\D 匹配任意非数字的字符 \\B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou] 匹配除了aeiou这几个字母以外的任意字符 后向引用 分类 代码/语法 说明 捕获 (exp) 匹配exp,并捕获文本到自动命名的组里 捕获 (?&lt;name&gt;exp) 匹配exp,并捕获文本到名称为name的组里，也可以写成(?&#39;name&#39;exp) 捕获 (?:exp) 匹配exp,不捕获匹配的文本，也不给此分组分配组号 零宽断言 (?=exp) 匹配exp前面的位置 零宽断言 (?&lt;=exp) 匹配exp后面的位置 零宽断言 (?!exp) 匹配后面跟的不是exp的位置 零宽断言 (?&lt;!exp) 匹配前面不是exp的位置 注释 (?#comment) 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读 贪婪与懒惰正则表达式通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号? 代码/语法 说明 *? 重复任意次，但尽可能少重复 +? 重复1次或更多次，但尽可能少重复 ?? 重复0次或1次，但尽可能少重复 {n,m}? 重复n到m次，但尽可能少重复 {n,}? 重复n次以上，但尽可能少重复 处理选项 名称 说明 IgnoreCase(忽略大小写) 匹配时不区分大小写。 Multiline(多行模式) 更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\\n之前的位置以及字符串结束前的位置.) Singleline(单行模式) 更改.的含义，使它与每一个字符匹配（包括换行符\\n）。 IgnorePatternWhitespace(忽略空白) 忽略表达式中的非转义空白并启用由#标记的注释。 ExplicitCapture(显式捕获) 仅捕获已被显式命名的组。 其他语法 代码/语法 说明 \\a 报警字符(打印它的效果是电脑嘀一声) \\b 通常是单词分界位置，但如果在字符类里使用代表退格 \\t 制表符，Tab \\r 回车 \\v 竖向制表符 \\f 换页符 \\n 换行符 \\e Escape \\0nn ASCII代码中八进制代码为nn的字符 \\xnn ASCII代码中十六进制代码为nn的字符 \\unnnn Unicode代码中十六进制代码为nnnn的字符 \\cN ASCII控制字符。比如\\cC代表Ctrl+C \\A 字符串开头(类似^，但不受处理多行选项的影响) \\Z 字符串结尾或行尾(不受处理多行选项的影响) \\z 字符串结尾(类似$，但不受处理多行选项的影响) `\\G 当前搜索的开头` \\p{name} Unicode中命名为name的字符类，例如\\p{IsGreek} `(?&gt;exp) 贪婪子表达式` (?&lt;x&gt;-&lt;y&gt;exp) 平衡组 (?im-nsx:exp) 在子表达式exp中改变处理选项 (?im-nsx) 为表达式后面的部分改变处理选项 (?(exp)yes no) 把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no (?(exp)yes) 同上，只是使用空表达式作为no (?(name)yes no) 如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no (?(name)yes) 同上，只是使用空表达式作为no","tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://www.chenc.cc/tags/正则表达式/"}]},{"title":"CSS选择器","date":"2017-03-09T13:21:32.000Z","path":"2017/03/09/FrontEnd/css-selector/","text":"ID选择器 #123#first-para &#123; font-weight : bold;&#125; 类选择器 .123.warning &#123; font-weight : bold;&#125; 多类选择器 .123456789.warning &#123; font-weight : bold; &#125;.urgent &#123; color : red;&#125;.warning.urgent &#123; background : silver;&#125; 通过把两个类选择器链接在一起，尽可以选择同时包含这些类名的元素(类名顺序不限)。 属性选择器 [ ] 带有某属性的元素 1234/* 带有class属性(值不限)的H1元素 */h1 [class] &#123; color : red;&#125; 带有多种属性的元素 1234/* 带有href和title属性(值不限)的a元素 */a [href] [title] &#123; color : red;&#125; 指定属性值的元素 1234/* 指定href属性值的a元素 */a [href=\"https://www.baidu.com\"] &#123; color : red;&#125; 12345678/* 指定class属性值为“urgent warning“的a元素,值顺序必须一致(完全串匹配) */p [class=\"urgent warning\"] &#123; font-weight : bold;&#125;&lt;p class=\"urgent warning\"&gt; Content&lt;/p&gt; 部分属性值 123456789101112131415161718192021222324/* class属性值中包含“warning“的a元素*/p [class~=\"warning\"] &#123; font-weight : bold;&#125;/* class属性值中以“warning“开头的a元素*/p [class^=\"warning\"] &#123; font-weight : bold;&#125;/* class属性值中以“warning“结尾的a元素*/p [class$=\"warning\"] &#123; font-weight : bold;&#125;/* class属性值中包含子串“warning“的a元素*/p [class*=\"warning\"] &#123; font-weight : bold;&#125;/* lang属性值中以“en“开头或值为“en”的元素*/* [lang |= \"en\"] &#123; font-weight : bold;&#125; 后代选择器 (空格)1234/* h1中的em 两个元素中间的层次间隔可以是无限的*/h1 em &#123; color : red;&#125; 选择子元素 &gt;1234/* h1的子元素strong 两个元素中间无层次间隔*/h1 &gt; strong &#123; color : red;&#125; 选择相邻兄弟元素 +1234/* 紧接着h1出现的p元素 */h1 + p &#123; margin-top : 0;&#125; 伪类选择器 :1234/* 访问过的a链接 */a:visited &#123; color : red;&#125; 链接伪类 伪类名 描述 :link 指示作为超链接(有一个href属性)并指向一个未访问地址的所有锚注意，有些浏览器可能会不正确地将:link解释为指向任何超链接，包括已访问和未访问的超链接 :visited 指示作为已访问地址超链接的锚。 动态伪类 伪类名 描述 :focus 指示当前拥有输入焦点的元素，也就是说，可以接受键盘输入或者能以某种方式激活的元素 :hover 指示鼠标指针停留在哪个元素上，例如，鼠标指针可能停留在一个超链接上，:hover就会指示这个超链接 :active 指示被用户输入激活的元素，例如，鼠标指针停留在一个超链接上时，如果用户点击鼠标，就会激活这个超链接，:active将指示这个超链接 注意：伪类的顺序很重要。建议 link-visited-foucus-hover-active。 第一个子元素 1234/* 第一个li */li:first-child &#123; text-transform : uppercase;&#125; 伪元素选择器 设置首字母样式 :first-letter 1234/* 段落的首字母 */p:first-letter &#123; color :red;&#125; 设置第一行样式 :first-line 1234/* 段落的首字母 */p:first-line &#123; color :red;&#125; 注意，:first-letter和:first-line伪元素只能应用于标记或段落之类的块级元素，而不能应用于超链接等行内元素。在CSS2.1中，:first-letter能应用到所有元素。 设置之前和之后元素的样式 :before :after 12345/* 在h2之前添加两个银色的大括号 */h2:before &#123; content : \"&#125;&#125;\"; color : silver;&#125;","tags":[{"name":"CSS","slug":"CSS","permalink":"http://www.chenc.cc/tags/CSS/"}]},{"title":"TiUP技术分享 -- 微信公众号开发","date":"2016-04-15T13:24:47.000Z","path":"2016/04/15/salon/tiup-salon-wechat-dev/","text":"今天在团队技术沙龙主讲了微信公众号的相关内容，现将讲稿发到这里","tags":[{"name":"技术沙龙","slug":"技术沙龙","permalink":"http://www.chenc.cc/tags/技术沙龙/"},{"name":"微信服务号","slug":"微信服务号","permalink":"http://www.chenc.cc/tags/微信服务号/"},{"name":"OAuth2.0","slug":"OAuth2-0","permalink":"http://www.chenc.cc/tags/OAuth2-0/"}]},{"title":"PHP哈希表碰撞攻击原理","date":"2016-03-16T00:12:43.000Z","path":"2016/03/16/PHP/php-gc/","text":"转载自伯乐在线 哈希表碰撞攻击的基本原理哈希表是一种查找效率极高的数据结构，很多语言都在内部实现了哈希表。PHP中的哈希表是一种极为重要的数据结构，不但用于表示Array数据类型，还在Zend虚拟机内部用于存储上下文环境信息（执行上下文的变量及函数均使用哈希表结构存储）。理想情况下哈希表插入和查找操作的时间复杂度均为O(1)，任何一个数据项可以在一个与哈希表长度无关的时间内计算出一个哈希值（key），然后在常量时间内定位到一个桶（术语bucket，表示哈希表中的一个位置）。当然这是理想情况下，因为任何哈希表的长度都是有限的，所以一定存在不同的数据项具有相同哈希值的情况，此时不同数据项被定为到同一个桶，称为碰撞（collision）。哈希表的实现需要解决碰撞问题，碰撞解决大体有两种思路，第一种是根据某种原则将被碰撞数据定为到其它桶，例如线性探测——如果数据在插入时发生了碰撞，则顺序查找这个桶后面的桶，将其放入第一个没有被使用的桶；第二种策略是每个桶不是一个只能容纳单个数据项的位置，而是一个可容纳多个数据的数据结构（例如链表或红黑树），所有碰撞的数据以某种数据结构的形式组织起来。 不论使用了哪种碰撞解决策略，都导致插入和查找操作的时间复杂度不再是O(1)。以查找为例，不能通过key定位到桶就结束，必须还要比较原始key（即未做哈希之前的key）是否相等，如果不相等，则要使用与插入相同的算法继续查找，直到找到匹配的值或确认数据不在哈希表中。 PHP是使用单链表存储碰撞的数据，因此实际上PHP哈希表的平均查找复杂度为O(L)，其中L为桶链表的平均长度；而最坏复杂度为O(N)，此时所有数据全部碰撞，哈希表退化成单链表。下图PHP中正常哈希表和退化哈希表的示意图。哈希表碰撞攻击就是通过精心构造数据，使得所有数据全部碰撞，人为将哈希表变成一个退化的单链表，此时哈希表各种操作的时间均提升了一个数量级，因此会消耗大量CPU资源，导致系统无法快速响应请求，从而达到拒绝服务攻击（DoS）的目的。 可以看到，进行哈希碰撞攻击的前提是哈希算法特别容易找出碰撞，如果是MD5或者SHA1那基本就没戏了，幸运的是（也可以说不幸的是）大多数编程语言使用的哈希算法都十分简单（这是为了效率考虑），因此可以不费吹灰之力之力构造出攻击数据。下一节将通过分析Zend相关内核代码，找出攻击哈希表碰撞攻击PHP的方法。 Zend哈希表的内部实现数据结构PHP中使用一个叫Backet的结构体表示桶，同一哈希值的所有桶被组织为一个单链表。哈希表使用HashTable结构体表示。相关源码在zend/Zend_hash.h下：1234567891011121314151617181920212223242526272829typedef struct bucket &#123; ulong h; /* Used for numeric indexing */ uint nKeyLength; void *pData; void *pDataPtr; struct bucket *pListNext; struct bucket *pListLast; struct bucket *pNext; struct bucket *pLast; char arKey[1]; /* Must be last element */&#125; Bucket; typedef struct _hashtable &#123; uint nTableSize; uint nTableMask; uint nNumOfElements; ulong nNextFreeElement; Bucket *pInternalPointer; /* Used for element traversal */ Bucket *pListHead; Bucket *pListTail; Bucket **arBuckets; dtor_func_t pDestructor; zend_bool persistent; unsigned char nApplyCount; zend_bool bApplyProtection;#if ZEND_DEBUG int inconsistent;#endif&#125; HashTable; 字段名很清楚的表明其用途，因此不做过多解释。重点明确下面几个字段：Bucket中的“h”用于存储原始key；HashTable中的nTableMask是一个掩码，一般被设为nTableSize – 1，与哈希算法有密切关系，后面讨论哈希算法时会详述；arBuckets指向一个指针数组，其中每个元素是一个指向Bucket链表的头指针。 哈希算法PHP哈希表最小容量是8（2^3），最大容量是0×80000000（2^31），并向2的整数次幂圆整（即长度会自动扩展为2的整数次幂，如13个元素的哈希表长度为16；100个元素的哈希表长度为128）。nTableMask被初始化为哈希表长度（圆整后）减1。具体代码在zend/Zend_hash.c的_zend_hash_init函数中，这里截取与本文相关的部分并加上少量注释。123456789101112131415161718192021222324ZEND_API int _zend_hash_init(HashTable *ht, uint nSize, hash_func_t pHashFunction, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)&#123; uint i = 3; Bucket **tmp; SET_INCONSISTENT(HT_OK); //长度向2的整数次幂圆整 if (nSize &amp;gt;= 0x80000000) &#123; /* prevent overflow */ ht-&amp;gt;nTableSize = 0x80000000; &#125; else &#123; while ((1U &amp;lt;&amp;lt; i) &amp;lt; nSize) &#123; i++; &#125; ht-&amp;gt;nTableSize = 1 &amp;lt;&amp;lt; i; &#125; ht-&amp;gt;nTableMask = ht-&amp;gt;nTableSize - 1; /*此处省略若干代码…*/ return SUCCESS;&#125; 值得一提的是PHP向2的整数次幂取圆整方法非常巧妙，可以背下来在需要的时候使用。 Zend HashTable的哈希算法异常简单：即简单将数据的原始key与HashTable的nTableMask进行按位与即可。如果原始key为字符串，则首先使用Times33算法将字符串转为整形再与nTableMask按位与。下面是Zend源码中查找哈希表的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243ZEND_API int zend_hash_index_find(const HashTable *ht, ulong h, void **pData)&#123; uint nIndex; Bucket *p; IS_CONSISTENT(ht); nIndex = h &amp; ht-&gt;nTableMask; p = ht-&gt;arBuckets[nIndex]; while (p != NULL) &#123; if ((p-&gt;h == h) &amp;&amp; (p-&gt;nKeyLength == 0)) &#123; *pData = p-&gt;pData; return SUCCESS; &#125; p = p-&gt;pNext; &#125; return FAILURE;&#125;ZEND_API int zend_hash_find(const HashTable *ht, const char *arKey, uint nKeyLength, void **pData)&#123; ulong h; uint nIndex; Bucket *p; IS_CONSISTENT(ht); h = zend_inline_hash_func(arKey, nKeyLength); nIndex = h &amp; ht-&gt;nTableMask; p = ht-&gt;arBuckets[nIndex]; while (p != NULL) &#123; if ((p-&gt;h == h) &amp;&amp; (p-&gt;nKeyLength == nKeyLength)) &#123; if (!memcmp(p-&gt;arKey, arKey, nKeyLength)) &#123; *pData = p-&gt;pData; return SUCCESS; &#125; &#125; p = p-&gt;pNext; &#125; return FAILURE;&#125; 其中zend_hash_index_find用于查找整数key的情况，zend_hash_find用于查找字符串key。逻辑基本一致，只是字符串key会通过zend_inline_hash_func转为整数key，zend_inline_hash_func封装了times33算法，具体代码就不贴出了。 攻击基本攻击知道了PHP内部哈希表的算法，就可以利用其原理构造用于攻击的数据。一种最简单的方法是利用掩码规律制造碰撞。上文提到Zend HashTable的长度nTableSize会被圆整为2的整数次幂，假设我们构造一个2^16的哈希表，则nTableSize的二进制表示为：1 0000 0000 0000 0000，而nTableMask = nTableSize – 1为：0 1111 1111 1111 1111。接下来，可以以0为初始值，以2^16为步长，制造足够多的数据，可以得到如下推测： 0000 0000 0000 0000 0000 &amp; 0 1111 1111 1111 1111 = 0 0001 0000 0000 0000 0000 &amp; 0 1111 1111 1111 1111 = 0 0010 0000 0000 0000 0000 &amp; 0 1111 1111 1111 1111 = 0 0011 0000 0000 0000 0000 &amp; 0 1111 1111 1111 1111 = 0 0100 0000 0000 0000 0000 &amp; 0 1111 1111 1111 1111 = 0 …… 概况来说只要保证后16位均为0，则与掩码位于后得到的哈希值全部碰撞在位置0。 下面是利用这个原理写的一段攻击代码：12345678910111213&lt;?php$size = pow(2, 16); $startTime = microtime(true); $array = array();for ($key = 0, $maxKey = ($size - 1) * $size; $key &lt;= $maxKey; $key += $size) &#123; $array[$key] = 0;&#125; $endTime = microtime(true); echo $endTime - $startTime, ' seconds', \"\\n\"; 这段代码在我的VPS上（单CPU，512M内存）上用了近88秒才完成，并且在此期间CPU资源几乎被用尽：而普通的同样大小的哈希表插入仅用时0.036秒：1234567891011121314&lt;?php $size = pow(2, 16); $startTime = microtime(true); $array = array();for ($key = 0, $maxKey = ($size - 1) * $size; $key &lt;= $size; $key += 1) &#123; $array[$key] = 0;&#125; $endTime = microtime(true); echo $endTime - $startTime, ' seconds', \"\\n\"; 可以证明第二段代码插入N个元素的时间在O(N)水平，而第一段攻击代码则需O(N^2)的时间去插入N个元素。 POST攻击当然，一般情况下很难遇到攻击者可以直接修改PHP代码的情况，但是攻击者仍可以通过一些方法间接构造哈希表来进行攻击。例如PHP会将接收到的HTTP POST请求中的数据构造为$_POST，而这是一个Array，内部就是通过Zend HashTable表示，因此攻击者只要构造一个含有大量碰撞key的post请求，就可以达到攻击的目的。具体做法不再演示。 防护POST攻击的防护针对POST方式的哈希碰撞攻击，目前PHP的防护措施是控制POST数据的数量。在&gt;=PHP5.3.9的版本中增加了一个配置项max_input_vars，用于标识一次http请求最大接收的参数个数，默认为1000。因此PHP5.3.x的用户可以通过升级至5.3.9来避免哈希碰撞攻击。5.2.x的用户可以使用这个patch：http://www.laruence.com/2011/12/30/2440.html。 另外的防护方法是在Web服务器层面进行处理，例如限制http请求body的大小和参数的数量等，这个是现在用的最多的临时处理方案。具体做法与不同Web服务器相关，不再详述。 其它防护上面的防护方法只是限制POST数据的数量，而不能彻底解决这个问题。例如，如果某个POST字段是一个json数据类型，会被PHPjson_decode，那么只要构造一个超大的json攻击数据照样可以达到攻击目的。理论上，只要PHP代码中某处构造Array的数据依赖于外部输入，则都可能造成这个问题，因此彻底的解决方案要从Zend底层HashTable的实现动手。一般来说有两种方式，一是限制每个桶链表的最长长度；二是使用其它数据结构如红黑树取代链表组织碰撞哈希（并不解决哈希碰撞，只是减轻攻击影响，将N个数据的操作时间从O(N^2)降至O(NlogN)，代价是普通情况下接近O(1)的操作均变为O(logN)）。 目前使用最多的仍然是POST数据攻击，因此建议生产环境的PHP均进行升级或打补丁。至于从数据结构层面修复这个问题，目前还没有任何方面的消息。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.chenc.cc/tags/PHP/"},{"name":"哈希碰撞","slug":"哈希碰撞","permalink":"http://www.chenc.cc/tags/哈希碰撞/"}]}]